#include "LKA_T_staliro.h"
#include "rtwtypes.h"
#include "LKA_T_staliro_private.h"
#include <string.h>
#include "mwmathutil.h"
#include "LKA_T_staliro_types.h"
#include <math.h>
#include "rt_logging_mmi.h"
#include "LKA_T_staliro_capi.h"
#include "LKA_T_staliro_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; extern ssExecutionInfo gblExecutionInfo ; RTWExtModeInfo *
gblRTWExtModeInfo = NULL ; void raccelForceExtModeShutdown ( boolean_T
extModeStartPktReceived ) { if ( ! extModeStartPktReceived ) { boolean_T
stopRequested = false ; rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 2 , &
stopRequested ) ; } rtExtModeShutdown ( 2 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 1 ; int_T gbl_raccel_NumST = 3 ; const char_T
* gbl_raccel_Version = "24.2 (R2024b) 21-Jun-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define gjbh1trjzm (-1)
#define bwoa2d4qeu (-1)
#define hpm0irhqc1 (-1)
#define jbznyvk4nl (-1)
#define bzrcm5agek (100.0)
#define cq3oop30h5 (0.0)
#define eb1sgplrpe (3)
#define hbbpvc4znc (0.0)
#define kxh2w31x4w (10)
B rtB ; X rtX ; DW rtDW ; ExtY rtY ; static SimStruct model_S ; SimStruct *
const rtS = & model_S ; static void ghrnejlwhuy ( const real_T A [ 16 ] ,
real_T B_e [ 16 ] ) ; static void mw3hm0er3e ( const real_T A [ 16 ] , real_T
F [ 16 ] ) ; static void cmw0kwnpvh ( const real_T b_SuJm [ 40 ] , const
real_T I2Jm [ 20 ] , const real_T b_Su1 [ 20 ] , const real_T b_Sx [ 100 ] ,
const real_T b_Hv [ 440 ] , real_T b_H [ 4 ] , real_T b_Ku1 [ 2 ] , real_T
b_Kut [ 20 ] , real_T b_Kx [ 10 ] , real_T b_Kv [ 44 ] , real_T b_Kr [ 40 ] )
; static int32_T jqw0p1kzpa ( real_T b_A [ 9 ] ) ; static real_T cxe2vkg4wi ( const real_T x [ 3 ] ) ; static void jylmeeyvqk ( const real_T b_A [ 9 ] , real_T b_B [ 9 ] ) ; static real_T olmmnsphgv ( const real_T x [ 3 ] ) ; static real_T hdev2on2e4 ( const real_T x [ 3 ] ) ; static real_T dmam3wjb2b ( int32_T n , const real_T x [ 9 ] , int32_T ix0 ) ; static int32_T jv5f2zx3r1 ( int32_T b_m , int32_T n , const real_T b_A [ 9 ] , int32_T ia0 ) ; static void gjkx5njujy ( int32_T b_m , int32_T n , const real_T b_A [ 9 ] , int32_T ia0 , const real_T x [ 9 ] , int32_T ix0 , real_T y [ 3 ] ) ; static void if2lkwyut3 ( int32_T b_m , int32_T n , real_T alpha1 , int32_T ix0 , const real_T y [ 3 ] , real_T b_A [ 9 ] , int32_T ia0 ) ; static void fx02qmdry3 ( const real_T b_A [ 9 ] , real_T Q [ 9 ] , real_T R [ 9 ] ) ; static real_T d51qh1ev1z ( const real_T b_Ac [ 12 ] , const int32_T iC [ 4 ] , int32_T nA , const real_T b_Linv [ 9 ] , real_T RLinv [ 9 ] , real_T b_D [ 9 ] , real_T b_H [ 9 ] ) ; static real_T c5g5wyzkzq ( const real_T b_A [ 3 ] , const real_T b_B [ 3 ] ) ; static void enofia1dwu ( int32_T kDrop , boolean_T iA [ 4 ] , int32_T * nA , int32_T iC [ 4 ] ) ; static void fhzpmegedn ( const real_T b_Linv [ 9 ] , const real_T b_Hinv [ 9 ] , const real_T f [ 3 ] , const real_T b_Ac [ 12 ] , const real_T b [ 4 ] , boolean_T iA [ 4 ] , int32_T maxiter , real_T FeasTol , real_T x [ 3 ] , real_T lambda [ 4 ] , int32_T * status ) ; static void kaaxjzuhhx ( const real_T rseq [ 20 ] , const real_T vseq [ 22 ] , real_T umin , real_T umax , int32_T switch_in , const real_T x [ 5 ] , real_T old_u , const boolean_T iA [ 4 ] , const real_T b_Mlim [ 4 ] , const real_T b_Mx [ 20 ] , const real_T b_Mu1 [ 4 ] , const real_T b_Mv [ 88 ] , const real_T b_utarget [ 10 ] , real_T b_uoff , int32_T b_enable_value , const real_T b_Ac [ 12 ] , const real_T b_A [ 25 ] , const real_T Bu [ 55 ] , const real_T Bv [ 110 ] , const real_T b_C [ 10 ] , const real_T Dv [ 44 ] , real_T * u , real_T useq [ 11 ] , real_T * status , boolean_T iAout [ 4 ] ) ; int32_T div_nde_s32_floor ( int32_T numerator , int32_T denominator ) { return ( ( ( numerator < 0 ) != ( denominator < 0 ) ) && ( numerator % denominator != 0 ) ? - 1 : 0 ) + numerator / denominator ; } void mgzh2u4e23 ( e5kxs0w0r0 * localDW ) { localDW -> am1q23zvbk = false ; localDW -> ad0pg2zl2x = gjbh1trjzm ; } void kj444jmrfp ( real_T gzcmrvxwtn , j031qli2g5 * localB , e5kxs0w0r0 * localDW ) { localDW -> ad0pg2zl2x = gjbh1trjzm ; localB -> onhvape52u = gzcmrvxwtn ; } void fcfdecnkl3 ( iqwltgu41w * localDW ) { localDW -> pckcm0tazc = false ; localDW -> akqsbdynir = bwoa2d4qeu ; } void hpytpcdps5 ( iqwltgu41w * localDW ) { localDW -> akqsbdynir = bwoa2d4qeu ; } void i1fgdxmeff ( fooi5fpqn2 * localDW ) { localDW -> mz5ndlrakh = false ; localDW -> ov2ak15hts = hpm0irhqc1 ; } void ea5jflxydi ( real_T bviwbnh0ex , ix5sine44a * localB , fooi5fpqn2 * localDW ) { localDW -> ov2ak15hts = hpm0irhqc1 ; localB -> mccd0iruvd = bviwbnh0ex ; } static void ghrnejlwhuy ( const real_T A [ 16 ] , real_T B_e [ 16 ] ) { real_T b_A [ 16 ] ; real_T s ; real_T smax ; int32_T b_b ; int32_T b_ix ; int32_T b_j ; int32_T c_k ; int32_T ix ; int32_T iy ; int32_T jj ; int8_T ipiv [ 4 ] ; int8_T ipiv_p ; memcpy ( & b_A [ 0 ] , & A [ 0 ] , sizeof ( real_T ) << 4U ) ; ipiv [ 0 ] = 1 ; ipiv [ 1 ] = 2 ; ipiv [ 2 ] = 3 ; ipiv [ 3 ] = 4 ; for ( b_j = 0 ; b_j < 3 ; b_j ++ ) { jj = b_j * 5 ; iy = 3 - b_j ; b_ix = 0 ; smax = muDoubleScalarAbs ( b_A [ jj ] ) ; for ( c_k = 2 ; c_k <= iy + 1 ; c_k ++ ) { s = muDoubleScalarAbs ( b_A [ ( jj + c_k ) - 1 ] ) ; if ( s > smax ) { b_ix = c_k - 1 ; smax = s ; } } if ( b_A [ jj + b_ix ] != 0.0 ) { if ( b_ix != 0 ) { ipiv [ b_j ] = ( int8_T ) ( ( b_j + b_ix ) + 1 ) ; iy = b_j + b_ix ; smax = b_A [ b_j ] ; b_A [ b_j ] = b_A [ iy ] ; b_A [ iy ] = smax ; iy += 4 ; smax = b_A [ b_j + 4 ] ; b_A [ b_j + 4 ] = b_A [ iy ] ; b_A [ iy ] = smax ; iy += 4 ; smax = b_A [ b_j + 8 ] ; b_A [ b_j + 8 ] = b_A [ iy ] ; b_A [ iy ] = smax ; iy += 4 ; smax = b_A [ b_j + 12 ] ; b_A [ b_j + 12 ] = b_A [ iy ] ; b_A [ iy ] = smax ; } iy = ( jj - b_j ) + 4 ; for ( b_ix = jj + 2 ; b_ix <= iy ; b_ix ++ ) { b_A [ b_ix - 1 ] /= b_A [ jj ] ; } } iy = 2 - b_j ; ix = jj + 6 ; for ( c_k = 0 ; c_k <= iy ; c_k ++ ) { if ( b_A [ ( ( c_k << 2 ) + jj ) + 4 ] != 0.0 ) { smax = - b_A [ ( ( c_k << 2 ) + jj ) + 4 ] ; b_b = ( ix - b_j ) + 2 ; for ( b_ix = ix ; b_ix <= b_b ; b_ix ++ ) { b_A [ b_ix - 1 ] += b_A [ ( ( jj + b_ix ) - ix ) + 1 ] * smax ; } } ix += 4 ; } } for ( b_j = 0 ; b_j < 3 ; b_j ++ ) { ipiv_p = ipiv [ b_j ] ; if ( b_j + 1 != ipiv_p ) { smax = B_e [ b_j ] ; B_e [ b_j ] = B_e [ ipiv_p - 1 ] ; B_e [ ipiv_p - 1 ] = smax ; smax = B_e [ b_j + 4 ] ; B_e [ b_j + 4 ] = B_e [ ipiv_p + 3 ] ; B_e [ ipiv_p + 3 ] = smax ; smax = B_e [ b_j + 8 ] ; B_e [ b_j + 8 ] = B_e [ ipiv_p + 7 ] ; B_e [ ipiv_p + 7 ] = smax ; smax = B_e [ b_j + 12 ] ; B_e [ b_j + 12 ] = B_e [ ipiv_p + 11 ] ; B_e [ ipiv_p + 11 ] = smax ; } } for ( b_j = 0 ; b_j < 4 ; b_j ++ ) { jj = b_j << 2 ; for ( iy = 0 ; iy < 4 ; iy ++ ) { b_ix = iy << 2 ; if ( B_e [ iy + jj ] != 0.0 ) { for ( ix = iy + 2 ; ix < 5 ; ix ++ ) { B_e [ ( ix + jj ) - 1 ] -= b_A [ ( ix + b_ix ) - 1 ] * B_e [ iy + jj ] ; } } } } for ( b_j = 0 ; b_j < 4 ; b_j ++ ) { jj = b_j << 2 ; for ( iy = 3 ; iy >= 0 ; iy -- ) { b_ix = iy << 2 ; if ( B_e [ iy + jj ] != 0.0 ) { B_e [ iy + jj ] /= b_A [ iy + b_ix ] ; for ( ix = 0 ; ix < iy ; ix ++ ) { B_e [ ix + jj ] -= B_e [ iy + jj ] * b_A [ ix + b_ix ] ; } } } } } static void mw3hm0er3e ( const real_T A [ 16 ] , real_T F [ 16 ] ) { real_T A2 [ 16 ] ; real_T A3 [ 16 ] ; real_T A4 [ 16 ] ; real_T A4_e [ 16 ] ; real_T A4_p [ 16 ] ; real_T V [ 16 ] ; real_T A3_e ; real_T A3_i ; real_T A3_p ; real_T b_s ; real_T normA ; int32_T b_i ; int32_T b_j ; int32_T i ; int32_T i_p ; static const real_T c [ 5 ] = { 0.01495585217958292 , 0.253939833006323 , 0.95041789961629319 , 2.097847961257068 , 5.3719203511481517 } ; static const uint8_T e [ 5 ] = { 3U , 5U , 7U , 9U , 13U } ; boolean_T exitg1 ; normA = 0.0 ; b_j = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( b_j < 4 ) ) { b_s = ( ( muDoubleScalarAbs ( A [ ( b_j << 2 ) + 1 ] ) + muDoubleScalarAbs ( A [ b_j << 2 ] ) ) + muDoubleScalarAbs ( A [ ( b_j << 2 ) + 2 ] ) ) + muDoubleScalarAbs ( A [ ( b_j << 2 ) + 3 ] ) ; if ( muDoubleScalarIsNaN ( b_s ) ) { normA = ( rtNaN ) ; exitg1 = true ; } else { if ( b_s > normA ) { normA = b_s ; } b_j ++ ; } } if ( normA <= 5.3719203511481517 ) { b_j = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( b_j < 5 ) ) { if ( normA <= c [ b_j ] ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A2 [ i_p + ( i << 2 ) ] = ( ( A [ ( i << 2 ) + 1 ] * A [ i_p + 4 ] + A [ i << 2 ] * A [ i_p ] ) + A [ ( i << 2 ) + 2 ] * A [ i_p + 8 ] ) + A [ ( i << 2 ) + 3 ] * A [ i_p + 12 ] ; } } if ( e [ b_j ] == 3 ) { memcpy ( & F [ 0 ] , & A2 [ 0 ] , sizeof ( real_T ) << 4U ) ; F [ 0 ] += 60.0 ; F [ 5 ] += 60.0 ; F [ 10 ] += 60.0 ; F [ 15 ] += 60.0 ; for ( i = 0 ; i < 4 ; i ++ ) { b_s = F [ ( i << 2 ) + 1 ] ; normA = F [ i << 2 ] ; A3_p = F [ ( i << 2 ) + 2 ] ; A3_e = F [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_p [ i_p + ( i << 2 ) ] = ( ( A [ i_p + 4 ] * b_s + normA * A [ i_p ] ) + A [ i_p + 8 ] * A3_p ) + A [ i_p + 12 ] * A3_e ; } } for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = A4_p [ i ] ; V [ i ] = 12.0 * A2 [ i ] ; } normA = 120.0 ; } else { for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A3 [ i_p + ( i << 2 ) ] = ( ( A2 [ ( i << 2 ) + 1 ] * A2 [ i_p + 4 ] + A2 [ i << 2 ] * A2 [ i_p ] ) + A2 [ ( i << 2 ) + 2 ] * A2 [ i_p + 8 ] ) + A2 [ ( i << 2 ) + 3 ] * A2 [ i_p + 12 ] ; } } if ( e [ b_j ] == 5 ) { for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = 420.0 * A2 [ i ] + A3 [ i ] ; } F [ 0 ] += 15120.0 ; F [ 5 ] += 15120.0 ; F [ 10 ] += 15120.0 ; F [ 15 ] += 15120.0 ; for ( i = 0 ; i < 4 ; i ++ ) { b_s = F [ ( i << 2 ) + 1 ] ; normA = F [ i << 2 ] ; A3_p = F [ ( i << 2 ) + 2 ] ; A3_e = F [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_p [ i_p + ( i << 2 ) ] = ( ( A [ i_p + 4 ] * b_s + normA * A [ i_p ] ) + A [ i_p + 8 ] * A3_p ) + A [ i_p + 12 ] * A3_e ; } } for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = A4_p [ i ] ; V [ i ] = 30.0 * A3 [ i ] + 3360.0 * A2 [ i ] ; } normA = 30240.0 ; } else { for ( i = 0 ; i < 4 ; i ++ ) { A3_e = A2 [ ( i << 2 ) + 1 ] ; normA = A2 [ i << 2 ] ; b_s = A2 [ ( i << 2 ) + 2 ] ; A3_p = A2 [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4 [ i_p + ( i << 2 ) ] = ( ( A3 [ i_p + 4 ] * A3_e + normA * A3 [ i_p ] ) + A3 [ i_p + 8 ] * b_s ) + A3 [ i_p + 12 ] * A3_p ; } } if ( e [ b_j ] == 7 ) { for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = ( 1512.0 * A3 [ i ] + A4 [ i ] ) + 277200.0 * A2 [ i ] ; } F [ 0 ] += 8.64864E+6 ; F [ 5 ] += 8.64864E+6 ; F [ 10 ] += 8.64864E+6 ; F [ 15 ] += 8.64864E+6 ; for ( i = 0 ; i < 4 ; i ++ ) { b_s = F [ ( i << 2 ) + 1 ] ; normA = F [ i << 2 ] ; A3_p = F [ ( i << 2 ) + 2 ] ; A3_e = F [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_p [ i_p + ( i << 2 ) ] = ( ( A [ i_p + 4 ] * b_s + normA * A [ i_p ] ) + A [ i_p + 8 ] * A3_p ) + A [ i_p + 12 ] * A3_e ; } } for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = A4_p [ i ] ; V [ i ] = ( 56.0 * A4 [ i ] + 25200.0 * A3 [ i ] ) + 1.99584E+6 * A2 [ i ] ; } normA = 1.729728E+7 ; } else if ( e [ b_j ] == 9 ) { for ( i = 0 ; i < 4 ; i ++ ) { A3_e = A2 [ ( i << 2 ) + 1 ] ; normA = A2 [ i << 2 ] ; b_s = A2 [ ( i << 2 ) + 2 ] ; A3_p = A2 [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { V [ i_p + ( i << 2 ) ] = ( ( A4 [ i_p + 4 ] * A3_e + normA * A4 [ i_p ] ) + A4 [ i_p + 8 ] * b_s ) + A4 [ i_p + 12 ] * A3_p ; } } for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = ( ( 3960.0 * A4 [ i ] + V [ i ] ) + 2.16216E+6 * A3 [ i ] ) + 3.027024E+8 * A2 [ i ] ; } F [ 0 ] += 8.8216128E+9 ; F [ 5 ] += 8.8216128E+9 ; F [ 10 ] += 8.8216128E+9 ; F [ 15 ] += 8.8216128E+9 ; for ( i = 0 ; i < 4 ; i ++ ) { b_s = F [ ( i << 2 ) + 1 ] ; normA = F [ i << 2 ] ; A3_p = F [ ( i << 2 ) + 2 ] ; A3_e = F [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_p [ i_p + ( i << 2 ) ] = ( ( A [ i_p + 4 ] * b_s + normA * A [ i_p ] ) + A [ i_p + 8 ] * A3_p ) + A [ i_p + 12 ] * A3_e ; } } for ( i = 0 ; i < 16 ; i ++ ) { F [ i ] = A4_p [ i ] ; V [ i ] = ( ( 90.0 * V [ i ] + 110880.0 * A4 [ i ] ) + 3.027024E+7 * A3 [ i ] ) + 2.0756736E+9 * A2 [ i ] ; } normA = 1.76432256E+10 ; } else { for ( i = 0 ; i < 16 ; i ++ ) { A3_p = A4 [ i ] ; b_s = A3 [ i ] ; A3_e = A2 [ i ] ; F [ i ] = ( 3.352212864E+10 * A3_p + 1.05594705216E+13 * b_s ) + 1.1873537964288E+15 * A3_e ; A4_p [ i ] = ( 16380.0 * b_s + A3_p ) + 4.08408E+7 * A3_e ; } F [ 0 ] += 3.238237626624E+16 ; F [ 5 ] += 3.238237626624E+16 ; F [ 10 ] += 3.238237626624E+16 ; F [ 15 ] += 3.238237626624E+16 ; for ( i = 0 ; i < 4 ; i ++ ) { A3_p = A4 [ i + 4 ] ; b_s = A4 [ i ] ; A3_e = A4 [ i + 8 ] ; A3_i = A4 [ i + 12 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_e [ i + ( i_p << 2 ) ] = ( ( ( A4_p [ ( i_p << 2 ) + 1 ] * A3_p + A4_p [ i_p << 2 ] * b_s ) + A4_p [ ( i_p << 2 ) + 2 ] * A3_e ) + A4_p [ ( i_p << 2 ) + 3 ] * A3_i ) + F [ ( i_p << 2 ) + i ] ; } } for ( i = 0 ; i < 4 ; i ++ ) { A3_p = A4_e [ ( i << 2 ) + 1 ] ; b_s = A4_e [ i << 2 ] ; A3_e = A4_e [ ( i << 2 ) + 2 ] ; A3_i = A4_e [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { F [ i_p + ( i << 2 ) ] = ( ( A [ i_p + 4 ] * A3_p + b_s * A [ i_p ] ) + A [ i_p + 8 ] * A3_e ) + A [ i_p + 12 ] * A3_i ; } } for ( i = 0 ; i < 16 ; i ++ ) { A4_p [ i ] = ( 182.0 * A4 [ i ] + 960960.0 * A3 [ i ] ) + 1.32324192E+9 * A2 [ i ] ; } for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { V [ i + ( i_p << 2 ) ] = ( ( ( ( ( A4_p [ ( i_p << 2 ) + 1 ] * A4 [ i + 4 ] + A4_p [ i_p << 2 ] * A4 [ i ] ) + A4_p [ ( i_p << 2 ) + 2 ] * A4 [ i + 8 ] ) + A4_p [ ( i_p << 2 ) + 3 ] * A4 [ i + 12 ] ) + A4 [ ( i_p << 2 ) + i ] * 6.704425728E+11 ) + A3 [ ( i_p << 2 ) + i ] * 1.29060195264E+14 ) + A2 [ ( i_p << 2 ) + i ] * 7.7717703038976E+15 ; } } normA = 6.476475253248E+16 ; } } } V [ 0 ] += normA ; V [ 5 ] += normA ; V [ 10 ] += normA ; V [ 15 ] += normA ; for ( b_j = 0 ; b_j < 16 ; b_j ++ ) { b_s = F [ b_j ] ; V [ b_j ] -= b_s ; F [ b_j ] = 2.0 * b_s ; } ghrnejlwhuy ( V , F ) ; F [ 0 ] ++ ; F [ 5 ] ++ ; F [ 10 ] ++ ; F [ 15 ] ++ ; exitg1 = true ; } else { b_j ++ ; } } } else { if ( muDoubleScalarIsInf ( normA ) || muDoubleScalarIsNaN ( normA ) ) { normA = 0.0 ; } else { b_s = normA / 5.3719203511481517 ; normA = muDoubleScalarFloor ( muDoubleScalarLog ( b_s ) / 0.69314718055994529 ) ; b_s *= muDoubleScalarPower ( 2.0 , - normA ) ; if ( b_s < 0.5 ) { normA -- ; b_s *= 2.0 ; } else if ( b_s >= 1.0 ) { normA ++ ; b_s *= 0.5 ; } if ( b_s == 0.5 ) { normA -- ; } } b_s = muDoubleScalarPower ( 2.0 , normA ) ; for ( i = 0 ; i < 16 ; i ++ ) { V [ i ] = A [ i ] / b_s ; } for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A2 [ i_p + ( i << 2 ) ] = ( ( V [ ( i << 2 ) + 1 ] * V [ i_p + 4 ] + V [ i << 2 ] * V [ i_p ] ) + V [ ( i << 2 ) + 2 ] * V [ i_p + 8 ] ) + V [ ( i << 2 ) + 3 ] * V [ i_p + 12 ] ; } } for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A3 [ i + ( i_p << 2 ) ] = ( ( A2 [ ( i_p << 2 ) + 1 ] * A2 [ i + 4 ] + A2 [ i_p << 2 ] * A2 [ i ] ) + A2 [ ( i_p << 2 ) + 2 ] * A2 [ i + 8 ] ) + A2 [ ( i_p << 2 ) + 3 ] * A2 [ i + 12 ] ; } b_s = A3 [ i + 4 ] ; A3_p = A3 [ i ] ; A3_e = A3 [ i + 8 ] ; A3_i = A3 [ i + 12 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4 [ i + ( i_p << 2 ) ] = ( ( A2 [ ( i_p << 2 ) + 1 ] * b_s + A2 [ i_p << 2 ] * A3_p ) + A2 [ ( i_p << 2 ) + 2 ] * A3_e ) + A2 [ ( i_p << 2 ) + 3 ] * A3_i ; } } for ( i = 0 ; i < 16 ; i ++ ) { A3_p = A4 [ i ] ; b_s = A3 [ i ] ; A3_e = A2 [ i ] ; F [ i ] = ( 3.352212864E+10 * A3_p + 1.05594705216E+13 * b_s ) + 1.1873537964288E+15 * A3_e ; A4_p [ i ] = ( 16380.0 * b_s + A3_p ) + 4.08408E+7 * A3_e ; } F [ 0 ] += 3.238237626624E+16 ; F [ 5 ] += 3.238237626624E+16 ; F [ 10 ] += 3.238237626624E+16 ; F [ 15 ] += 3.238237626624E+16 ; for ( i = 0 ; i < 4 ; i ++ ) { A3_p = A4 [ i + 4 ] ; b_s = A4 [ i ] ; A3_e = A4 [ i + 8 ] ; A3_i = A4 [ i + 12 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { A4_e [ i + ( i_p << 2 ) ] = ( ( ( A4_p [ ( i_p << 2 ) + 1 ] * A3_p + A4_p [ i_p << 2 ] * b_s ) + A4_p [ ( i_p << 2 ) + 2 ] * A3_e ) + A4_p [ ( i_p << 2 ) + 3 ] * A3_i ) + F [ ( i_p << 2 ) + i ] ; } } for ( i = 0 ; i < 4 ; i ++ ) { A3_p = A4_e [ ( i << 2 ) + 1 ] ; b_s = A4_e [ i << 2 ] ; A3_e = A4_e [ ( i << 2 ) + 2 ] ; A3_i = A4_e [ ( i << 2 ) + 3 ] ; for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { F [ i_p + ( i << 2 ) ] = ( ( V [ i_p + 4 ] * A3_p + b_s * V [ i_p ] ) + V [ i_p + 8 ] * A3_e ) + V [ i_p + 12 ] * A3_i ; } } for ( i = 0 ; i < 16 ; i ++ ) { A4_p [ i ] = ( 182.0 * A4 [ i ] + 960960.0 * A3 [ i ] ) + 1.32324192E+9 * A2 [ i ] ; } for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { V [ i + ( i_p << 2 ) ] = ( ( ( ( ( A4_p [ ( i_p << 2 ) + 1 ] * A4 [ i + 4 ] + A4_p [ i_p << 2 ] * A4 [ i ] ) + A4_p [ ( i_p << 2 ) + 2 ] * A4 [ i + 8 ] ) + A4_p [ ( i_p << 2 ) + 3 ] * A4 [ i + 12 ] ) + A4 [ ( i_p << 2 ) + i ] * 6.704425728E+11 ) + A3 [ ( i_p << 2 ) + i ] * 1.29060195264E+14 ) + A2 [ ( i_p << 2 ) + i ] * 7.7717703038976E+15 ; } } V [ 0 ] += 6.476475253248E+16 ; V [ 5 ] += 6.476475253248E+16 ; V [ 10 ] += 6.476475253248E+16 ; V [ 15 ] += 6.476475253248E+16 ; for ( b_j = 0 ; b_j < 16 ; b_j ++ ) { b_s = F [ b_j ] ; V [ b_j ] -= b_s ; F [ b_j ] = 2.0 * b_s ; } ghrnejlwhuy ( V , F ) ; F [ 0 ] ++ ; F [ 5 ] ++ ; F [ 10 ] ++ ; F [ 15 ] ++ ; b_j = ( int32_T ) normA ; for ( b_i = 0 ; b_i < b_j ; b_i ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( i_p = 0 ; i_p < 4 ; i_p ++ ) { V [ i + ( i_p << 2 ) ] = ( ( F [ ( i_p << 2 ) + 1 ] * F [ i + 4 ] + F [ i_p << 2 ] * F [ i ] ) + F [ ( i_p << 2 ) + 2 ] * F [ i + 8 ] ) + F [ ( i_p << 2 ) + 3 ] * F [ i + 12 ] ; } } memcpy ( & F [ 0 ] , & V [ 0 ] , sizeof ( real_T ) << 4U ) ; } } } static void cmw0kwnpvh ( const real_T b_SuJm [ 40 ] , const real_T I2Jm [ 20 ] , const real_T b_Su1 [ 20 ] , const real_T b_Sx [ 100 ] , const real_T b_Hv [ 440 ] , real_T b_H [ 4 ] , real_T b_Ku1 [ 2 ] , real_T b_Kut [ 20 ] , real_T b_Kx [ 10 ] , real_T b_Kv [ 44 ] , real_T b_Kr [ 40 ] ) { ptrdiff_t k_t ; ptrdiff_t lda_t ; ptrdiff_t ldb_t ; ptrdiff_t ldc_t ; ptrdiff_t m_t ; ptrdiff_t n_t ; real_T I2Jm_p [ 4 ] ; real_T b_SuJm_p [ 4 ] ; real_T alpha1 ; real_T beta1 ; int32_T i ; int32_T i_e ; int32_T i_p ; int16_T ixw ; char_T TRANSA1 ; char_T TRANSB1 ; static const real_T W [ 2 ] = { 1.0 , 0.010000000000000002 } ; static const real_T b [ 4 ] = { 0.010000000000000002 , 0.0 , 0.0 , 0.010000000000000002 } ; ixw = 1 ; for ( i = 0 ; i < 20 ; i ++ ) { beta1 = W [ ixw - 1 ] ; b_Kr [ i ] = beta1 * b_SuJm [ i ] ; b_Kr [ i + 20 ] = b_SuJm [ i + 20 ] * beta1 ; ixw ++ ; if ( ixw > 2 ) { ixw = 1 ; } b_Kut [ i ] = I2Jm [ i ] * cq3oop30h5 ; } for ( i = 0 ; i < 2 ; i ++ ) { for ( i_p = 0 ; i_p < 2 ; i_p ++ ) { beta1 = 0.0 ; for ( i_e = 0 ; i_e < 20 ; i_e ++ ) { beta1 += b_SuJm [ 20 * i + i_e ] * b_Kr [ 20 * i_p + i_e ] ; } b_SuJm_p [ i + ( i_p << 1 ) ] = b [ ( i_p << 1 ) + i ] + beta1 ; beta1 = 0.0 ; for ( i_e = 0 ; i_e < 10 ; i_e ++ ) { beta1 += I2Jm [ 10 * i + i_e ] * b_Kut [ 10 * i_p + i_e ] ; } I2Jm_p [ i + ( i_p << 1 ) ] = beta1 ; } alpha1 = 0.0 ; for ( i_p = 0 ; i_p < 20 ; i_p ++ ) { alpha1 += b_Kr [ 20 * i + i_p ] * b_Su1 [ i_p ] ; } beta1 = 0.0 ; for ( i_p = 0 ; i_p < 10 ; i_p ++ ) { beta1 += b_Kut [ 10 * i + i_p ] ; } b_Ku1 [ i ] = alpha1 + beta1 ; } b_H [ 0 ] = b_SuJm_p [ 0 ] + I2Jm_p [ 0 ] ; b_H [ 1 ] = b_SuJm_p [ 1 ] + I2Jm_p [ 1 ] ; b_H [ 2 ] = b_SuJm_p [ 2 ] + I2Jm_p [ 2 ] ; b_H [ 3 ] = b_SuJm_p [ 3 ] + I2Jm_p [ 3 ] ; for ( i = 0 ; i < 20 ; i ++ ) { b_Kut [ i ] = - b_Kut [ i ] ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( i_p = 0 ; i_p < 2 ; i_p ++ ) { beta1 = 0.0 ; for ( i_e = 0 ; i_e < 20 ; i_e ++ ) { beta1 += b_Sx [ 20 * i + i_e ] * b_Kr [ 20 * i_p + i_e ] ; } b_Kx [ i + 5 * i_p ] = beta1 ; } } TRANSB1 = 'N' ; TRANSA1 = 'T' ; beta1 = 0.0 ; alpha1 = 1.0 ; m_t = ( ptrdiff_t ) 22 ; n_t = ( ptrdiff_t ) 2 ; k_t = ( ptrdiff_t ) 20 ; lda_t = ( ptrdiff_t ) 20 ; ldb_t = ( ptrdiff_t ) 20 ; ldc_t = ( ptrdiff_t ) 22 ; dgemm ( & TRANSA1 , & TRANSB1 , & m_t , & n_t , & k_t , & alpha1 , & b_Hv [ 0 ] , & lda_t , & b_Kr [ 0 ] , & ldb_t , & beta1 , & b_Kv [ 0 ] , & ldc_t ) ; for ( i = 0 ; i < 40 ; i ++ ) { b_Kr [ i ] = - b_Kr [ i ] ; } } static int32_T jqw0p1kzpa ( real_T b_A [ 9 ] ) { ptrdiff_t incx_t ; ptrdiff_t incy_t ; ptrdiff_t lda_t ; ptrdiff_t m_t ; ptrdiff_t n_t ; real_T alpha1 ; real_T beta1 ; real_T ssq ; int32_T b_k ; int32_T idxAjj ; int32_T info ; int32_T j ; int32_T jm1 ; char_T TRANSA ; boolean_T exitg1 ; info = 0 ; j = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( j < 3 ) ) { idxAjj = j * 3 + j ; ssq = 0.0 ; if ( j >= 1 ) { for ( b_k = 0 ; b_k < j ; b_k ++ ) { ssq += b_A [ b_k * 3 + j ] * b_A [ b_k * 3 + j ] ; } } ssq = b_A [ idxAjj ] - ssq ; if ( ssq > 0.0 ) { ssq = muDoubleScalarSqrt ( ssq ) ; b_A [ idxAjj ] = ssq ; if ( j + 1 < 3 ) { if ( j >= 1 ) { alpha1 = - 1.0 ; beta1 = 1.0 ; TRANSA = 'N' ; m_t = ( ptrdiff_t ) ( 2 - j ) ; n_t = ( ptrdiff_t ) j ; lda_t = ( ptrdiff_t ) 3 ; incx_t = ( ptrdiff_t ) 3 ; incy_t = ( ptrdiff_t ) 1 ; dgemv ( & TRANSA , & m_t , & n_t , & alpha1 , & b_A [ j + 1 ] , & lda_t , & b_A [ j ] , & incx_t , & beta1 , & b_A [ idxAjj + 1 ] , & incy_t ) ; } ssq = 1.0 / ssq ; jm1 = ( idxAjj - j ) + 3 ; for ( b_k = idxAjj + 2 ; b_k <= jm1 ; b_k ++ ) { b_A [ b_k - 1 ] *= ssq ; } } j ++ ; } else { b_A [ idxAjj ] = ssq ; info = j + 1 ; exitg1 = true ; } } return info ; } static real_T cxe2vkg4wi ( const real_T x [ 3 ] ) { real_T ex ; real_T x_p ; int32_T idx ; int32_T k ; boolean_T exitg1 ; if ( ! muDoubleScalarIsNaN ( x [ 0 ] ) ) { idx = 1 ; } else { idx = 0 ; k = 2 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 4 ) ) { if ( ! muDoubleScalarIsNaN ( x [ k - 1 ] ) ) { idx = k ; exitg1 = true ; } else { k ++ ; } } } if ( idx == 0 ) { ex = x [ 0 ] ; } else { ex = x [ idx - 1 ] ; for ( k = idx + 1 ; k < 4 ; k ++ ) { x_p = x [ k - 1 ] ; if ( ex > x_p ) { ex = x_p ; } } } return ex ; } static void jylmeeyvqk ( const real_T b_A [ 9 ] , real_T b_B [ 9 ] ) { real_T b_B_p ; int32_T b_k ; int32_T i ; int32_T j ; int32_T jBcol ; int32_T kAcol ; for ( j = 0 ; j < 3 ; j ++ ) { jBcol = 3 * j ; for ( b_k = 0 ; b_k < 3 ; b_k ++ ) { kAcol = 3 * b_k ; b_B_p = b_B [ b_k + jBcol ] ; if ( b_B_p != 0.0 ) { b_B_p /= b_A [ b_k + kAcol ] ; b_B [ b_k + jBcol ] = b_B_p ; for ( i = b_k + 2 ; i < 4 ; i ++ ) { b_B [ ( i + jBcol ) - 1 ] -= b_A [ ( i + kAcol ) - 1 ] * b_B [ b_k + jBcol ] ; } } } } } static real_T olmmnsphgv ( const real_T x [ 3 ] ) { real_T absxk ; real_T scale ; real_T t ; real_T y ; scale = 3.3121686421112381E-170 ; absxk = muDoubleScalarAbs ( x [ 0 ] ) ; if ( absxk > 3.3121686421112381E-170 ) { y = 1.0 ; scale = absxk ; } else { t = absxk / 3.3121686421112381E-170 ; y = t * t ; } absxk = muDoubleScalarAbs ( x [ 1 ] ) ; if ( absxk > scale ) { t = scale / absxk ; y = y * t * t + 1.0 ; scale = absxk ; } else { t = absxk / scale ; y += t * t ; } absxk = muDoubleScalarAbs ( x [ 2 ] ) ; if ( absxk > scale ) { t = scale / absxk ; y = y * t * t + 1.0 ; scale = absxk ; } else { t = absxk / scale ; y += t * t ; } return scale * muDoubleScalarSqrt ( y ) ; } static real_T hdev2on2e4 ( const real_T x [ 3 ] ) { real_T ex ; real_T x_p ; int32_T idx ; int32_T k ; boolean_T exitg1 ; if ( ! muDoubleScalarIsNaN ( x [ 0 ] ) ) { idx = 1 ; } else { idx = 0 ; k = 2 ; exitg1 = false ; while ( ( ! exitg1 ) && ( k < 4 ) ) { if ( ! muDoubleScalarIsNaN ( x [ k - 1 ] ) ) { idx = k ; exitg1 = true ; } else { k ++ ; } } } if ( idx == 0 ) { ex = x [ 0 ] ; } else { ex = x [ idx - 1 ] ; for ( k = idx + 1 ; k < 4 ; k ++ ) { x_p = x [ k - 1 ] ; if ( ex < x_p ) { ex = x_p ; } } } return ex ; } static real_T dmam3wjb2b ( int32_T n , const real_T x [ 9 ] , int32_T ix0 ) { real_T absxk ; real_T scale ; real_T t ; real_T y ; int32_T k ; int32_T kend ; y = 0.0 ; if ( n >= 1 ) { if ( n == 1 ) { y = muDoubleScalarAbs ( x [ ix0 - 1 ] ) ; } else { scale = 3.3121686421112381E-170 ; kend = ix0 + n ; for ( k = ix0 ; k < kend ; k ++ ) { absxk = muDoubleScalarAbs ( x [ k - 1 ] ) ; if ( absxk > scale ) { t = scale / absxk ; y = y * t * t + 1.0 ; scale = absxk ; } else { t = absxk / scale ; y += t * t ; } } y = scale * muDoubleScalarSqrt ( y ) ; } } return y ; } static int32_T jv5f2zx3r1 ( int32_T b_m , int32_T n , const real_T b_A [ 9 ] , int32_T ia0 ) { int32_T coltop ; int32_T exitg1 ; int32_T ia ; int32_T j ; boolean_T exitg2 ; j = n ; exitg2 = false ; while ( ( ! exitg2 ) && ( j > 0 ) ) { coltop = ( j - 1 ) * 3 + ia0 ; ia = coltop ; do { exitg1 = 0 ; if ( ia <= ( coltop + b_m ) - 1 ) { if ( b_A [ ia - 1 ] != 0.0 ) { exitg1 = 1 ; } else { ia ++ ; } } else { j -- ; exitg1 = 2 ; } } while ( exitg1 == 0 ) ; if ( exitg1 == 1 ) { exitg2 = true ; } } return j ; } static void gjkx5njujy ( int32_T b_m , int32_T n , const real_T b_A [ 9 ] , int32_T ia0 , const real_T x [ 9 ] , int32_T ix0 , real_T y [ 3 ] ) { real_T c ; int32_T b ; int32_T b_b ; int32_T b_iy ; int32_T ia ; if ( ( b_m != 0 ) && ( n != 0 ) ) { if ( n - 1 >= 0 ) { memset ( & y [ 0 ] , 0 , ( uint32_T ) n * sizeof ( real_T ) ) ; } b = ( n - 1 ) * 3 + ia0 ; for ( b_iy = ia0 ; b_iy <= b ; b_iy += 3 ) { c = 0.0 ; b_b = b_iy + b_m ; for ( ia = b_iy ; ia < b_b ; ia ++ ) { c += x [ ( ( ix0 + ia ) - b_iy ) - 1 ] * b_A [ ia - 1 ] ; } y [ div_nde_s32_floor ( b_iy - ia0 , 3 ) ] = y [ div_nde_s32_floor ( b_iy - ia0 , 3 ) ] + c ; } } } static void if2lkwyut3 ( int32_T b_m , int32_T n , real_T alpha1 , int32_T ix0 , const real_T y [ 3 ] , real_T b_A [ 9 ] , int32_T ia0 ) { real_T temp ; int32_T b ; int32_T ijA ; int32_T j ; int32_T jA ; if ( ! ( alpha1 == 0.0 ) ) { jA = ia0 ; for ( j = 0 ; j < n ; j ++ ) { temp = y [ j ] ; if ( temp != 0.0 ) { temp *= alpha1 ; b = b_m + jA ; for ( ijA = jA ; ijA < b ; ijA ++ ) { b_A [ ijA - 1 ] += b_A [ ( ( ix0 + ijA ) - jA ) - 1 ] * temp ; } } jA += 3 ; } } } static void fx02qmdry3 ( const real_T b_A [ 9 ] , real_T Q [ 9 ] , real_T R [ 9 ] ) { real_T c_A [ 9 ] ; real_T tau [ 3 ] ; real_T work [ 3 ] ; real_T atmp ; real_T c_A_p ; real_T xnorm ; int32_T b_lastv ; int32_T c_k ; int32_T ii ; int32_T itau ; int32_T knt ; int32_T lastc ; memcpy ( & c_A [ 0 ] , & b_A [ 0 ] , 9U * sizeof ( real_T ) ) ; work [ 0 ] = 0.0 ; work [ 1 ] = 0.0 ; work [ 2 ] = 0.0 ; for ( itau = 0 ; itau < 3 ; itau ++ ) { ii = itau * 3 + itau ; if ( itau + 1 < 3 ) { atmp = c_A [ ii ] ; b_lastv = ii + 2 ; tau [ itau ] = 0.0 ; xnorm = dmam3wjb2b ( 2 - itau , c_A , ii + 2 ) ; if ( xnorm != 0.0 ) { c_A_p = c_A [ ii ] ; xnorm = muDoubleScalarHypot ( c_A_p , xnorm ) ; if ( c_A_p >= 0.0 ) { xnorm = - xnorm ; } if ( muDoubleScalarAbs ( xnorm ) < 1.0020841800044864E-292 ) { knt = - 1 ; do { knt ++ ; lastc = ( ii - itau ) + 3 ; for ( c_k = b_lastv ; c_k <= lastc ; c_k ++ ) { c_A [ c_k - 1 ] *= 9.9792015476736E+291 ; } xnorm *= 9.9792015476736E+291 ; atmp *= 9.9792015476736E+291 ; } while ( ( muDoubleScalarAbs ( xnorm ) < 1.0020841800044864E-292 ) && ( knt + 1 < 20 ) ) ; xnorm = muDoubleScalarHypot ( atmp , dmam3wjb2b ( 2 - itau , c_A , ii + 2 ) ) ; if ( atmp >= 0.0 ) { xnorm = - xnorm ; } tau [ itau ] = ( xnorm - atmp ) / xnorm ; atmp = 1.0 / ( atmp - xnorm ) ; lastc = ( ii - itau ) + 3 ; for ( c_k = b_lastv ; c_k <= lastc ; c_k ++ ) { c_A [ c_k - 1 ] *= atmp ; } for ( b_lastv = 0 ; b_lastv <= knt ; b_lastv ++ ) { xnorm *= 1.0020841800044864E-292 ; } atmp = xnorm ; } else { tau [ itau ] = ( xnorm - c_A_p ) / xnorm ; atmp = 1.0 / ( c_A_p - xnorm ) ; knt = ( ii - itau ) + 3 ; for ( lastc = b_lastv ; lastc <= knt ; lastc ++ ) { c_A [ lastc - 1 ] *= atmp ; } atmp = xnorm ; } } c_A [ ii ] = 1.0 ; if ( tau [ itau ] != 0.0 ) { b_lastv = 3 - itau ; knt = ( ii - itau ) + 2 ; while ( ( b_lastv > 0 ) && ( c_A [ knt ] == 0.0 ) ) { b_lastv -- ; knt -- ; } knt = jv5f2zx3r1 ( b_lastv , 2 - itau , c_A , ii + 4 ) ; } else { b_lastv = 0 ; knt = 0 ; } if ( b_lastv > 0 ) { gjkx5njujy ( b_lastv , knt , c_A , ii + 4 , c_A , ii + 1 , work ) ; if2lkwyut3 ( b_lastv , knt , - tau [ itau ] , ii + 1 , work , c_A , ii + 4 ) ; } c_A [ ii ] = atmp ; } else { tau [ 2 ] = 0.0 ; } } for ( itau = 0 ; itau < 3 ; itau ++ ) { for ( ii = 0 ; ii <= itau ; ii ++ ) { R [ ii + 3 * itau ] = c_A [ 3 * itau + ii ] ; } for ( ii = itau + 2 ; ii < 4 ; ii ++ ) { R [ ( ii + 3 * itau ) - 1 ] = 0.0 ; } work [ itau ] = 0.0 ; } for ( ii = 2 ; ii >= 0 ; ii -- ) { b_lastv = ( ii * 3 + ii ) + 4 ; if ( ii + 1 < 3 ) { c_A [ b_lastv - 4 ] = 1.0 ; if ( tau [ ii ] != 0.0 ) { knt = 3 - ii ; lastc = b_lastv - ii ; while ( ( knt > 0 ) && ( c_A [ lastc - 2 ] == 0.0 ) ) { knt -- ; lastc -- ; } lastc = jv5f2zx3r1 ( knt , 2 - ii , c_A , b_lastv ) ; } else { knt = 0 ; lastc = 0 ; } if ( knt > 0 ) { gjkx5njujy ( knt , lastc , c_A , b_lastv , c_A , b_lastv - 3 , work ) ; if2lkwyut3 ( knt , lastc , - tau [ ii ] , b_lastv - 3 , work , c_A , b_lastv ) ; } knt = b_lastv - ii ; for ( lastc = b_lastv - 2 ; lastc < knt ; lastc ++ ) { c_A [ lastc - 1 ] *= - tau [ ii ] ; } } c_A [ b_lastv - 4 ] = 1.0 - tau [ ii ] ; for ( knt = 0 ; knt < ii ; knt ++ ) { c_A [ ( b_lastv - knt ) - 5 ] = 0.0 ; } } for ( itau = 0 ; itau < 3 ; itau ++ ) { Q [ 3 * itau ] = c_A [ 3 * itau ] ; Q [ 3 * itau + 1 ] = c_A [ 3 * itau + 1 ] ; Q [ 3 * itau + 2 ] = c_A [ 3 * itau + 2 ] ; } } static real_T d51qh1ev1z ( const real_T b_Ac [ 12 ] , const int32_T iC [ 4 ] , int32_T nA , const real_T b_Linv [ 9 ] , real_T RLinv [ 9 ] , real_T b_D [ 9 ] , real_T b_H [ 9 ] ) { real_T QQ [ 9 ] ; real_T RR [ 9 ] ; real_T TL [ 9 ] ; real_T Status ; real_T b_Linv_e ; real_T b_Linv_i ; real_T b_Linv_p ; int32_T b_i ; int32_T exitg1 ; int32_T iC_p ; int32_T j ; Status = 1.0 ; memset ( & RLinv [ 0 ] , 0 , 9U * sizeof ( real_T ) ) ; for ( b_i = 0 ; b_i < nA ; b_i ++ ) { iC_p = iC [ b_i ] ; for ( j = 0 ; j < 3 ; j ++ ) { RLinv [ j + 3 * b_i ] = ( b_Ac [ iC_p - 1 ] * b_Linv [ j ] + b_Linv [ j + 3 ] * b_Ac [ iC_p + 3 ] ) + b_Linv [ j + 6 ] * b_Ac [ iC_p + 7 ] ; } } fx02qmdry3 ( RLinv , QQ , RR ) ; b_i = 0 ; do { exitg1 = 0 ; if ( b_i <= nA - 1 ) { if ( muDoubleScalarAbs ( RR [ 3 * b_i + b_i ] ) < 1.0E-12 ) { Status = - 2.0 ; exitg1 = 1 ; } else { b_i ++ ; } } else { for ( b_i = 0 ; b_i < 3 ; b_i ++ ) { b_Linv_p = b_Linv [ 3 * b_i + 1 ] ; b_Linv_e = b_Linv [ 3 * b_i ] ; b_Linv_i = b_Linv [ 3 * b_i + 2 ] ; for ( j = 0 ; j < 3 ; j ++ ) { TL [ b_i + 3 * j ] = ( QQ [ 3 * j + 1 ] * b_Linv_p + QQ [ 3 * j ] * b_Linv_e ) + QQ [ 3 * j + 2 ] * b_Linv_i ; } } memset ( & RLinv [ 0 ] , 0 , 9U * sizeof ( real_T ) ) ; for ( b_i = nA ; b_i >= 1 ; b_i -- ) { RLinv [ ( b_i + 3 * ( b_i - 1 ) ) - 1 ] = 1.0 ; for ( j = b_i ; j <= nA ; j ++ ) { RLinv [ ( b_i + 3 * ( j - 1 ) ) - 1 ] /= RR [ ( ( b_i - 1 ) * 3 + b_i ) - 1 ] ; } if ( b_i > 1 ) { for ( j = 0 ; j <= b_i - 2 ; j ++ ) { for ( iC_p = b_i ; iC_p <= nA ; iC_p ++ ) { RLinv [ j + 3 * ( iC_p - 1 ) ] -= RLinv [ ( ( iC_p - 1 ) * 3 + b_i ) - 1 ] * RR [ ( b_i - 1 ) * 3 + j ] ; } } } } for ( b_i = 0 ; b_i < 3 ; b_i ++ ) { for ( j = b_i + 1 ; j < 4 ; j ++ ) { b_H [ b_i + 3 * ( j - 1 ) ] = 0.0 ; for ( iC_p = nA + 1 ; iC_p < 4 ; iC_p ++ ) { b_H [ b_i + 3 * ( j - 1 ) ] -= TL [ ( ( iC_p - 1 ) * 3 + j ) - 1 ] * TL [ ( iC_p - 1 ) * 3 + b_i ] ; } b_H [ ( j + 3 * b_i ) - 1 ] = b_H [ ( j - 1 ) * 3 + b_i ] ; } } for ( b_i = 0 ; b_i < nA ; b_i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { b_D [ j + 3 * b_i ] = 0.0 ; for ( iC_p = b_i + 1 ; iC_p <= nA ; iC_p ++ ) { b_D [ j + 3 * b_i ] += TL [ ( iC_p - 1 ) * 3 + j ] * RLinv [ ( iC_p - 1 ) * 3 + b_i ] ; } } } exitg1 = 1 ; } } while ( exitg1 == 0 ) ; return Status ; } static real_T c5g5wyzkzq ( const real_T b_A [ 3 ] , const real_T b_B [ 3 ] ) { return ( b_A [ 0 ] * b_B [ 0 ] + b_A [ 1 ] * b_B [ 1 ] ) + b_A [ 2 ] * b_B [ 2 ] ; } static void enofia1dwu ( int32_T kDrop , boolean_T iA [ 4 ] , int32_T * nA , int32_T iC [ 4 ] ) { int32_T i ; if ( kDrop > 0 ) { iA [ iC [ kDrop - 1 ] - 1 ] = false ; if ( kDrop < * nA ) { for ( i = kDrop ; i < * nA ; i ++ ) { iC [ i - 1 ] = iC [ i ] ; } } iC [ * nA - 1 ] = 0 ; ( * nA ) -- ; } } static void fhzpmegedn ( const real_T b_Linv [ 9 ] , const real_T b_Hinv [ 9 ] , const real_T f [ 3 ] , const real_T b_Ac [ 12 ] , const real_T b [ 4 ] , boolean_T iA [ 4 ] , int32_T maxiter , real_T FeasTol , real_T x [ 3 ] , real_T lambda [ 4 ] , int32_T * status ) { real_T RLinv [ 9 ] ; real_T U [ 9 ] ; real_T b_D [ 9 ] ; real_T b_H [ 9 ] ; real_T Opt [ 6 ] ; real_T Rhs [ 6 ] ; real_T cTol [ 4 ] ; real_T b_Ac_p [ 3 ] ; real_T r [ 3 ] ; real_T z [ 3 ] ; real_T Xnorm0 ; real_T cMin ; real_T cVal ; real_T rMin ; real_T t ; int32_T iC [ 4 ] ; int32_T b_exponent ; int32_T exitg1 ; int32_T exitg3 ; int32_T exponent ; int32_T iC_p ; int32_T iSave ; int32_T kDrop ; int32_T kNext ; int32_T nA ; boolean_T ColdReset ; boolean_T DualFeasible ; boolean_T cTolComputed ; boolean_T exitg2 ; boolean_T exitg4 ; boolean_T guard1 ; boolean_T guard2 ; x [ 0 ] = 0.0 ; x [ 1 ] = 0.0 ; x [ 2 ] = 0.0 ; lambda [ 0 ] = 0.0 ; lambda [ 1 ] = 0.0 ; lambda [ 2 ] = 0.0 ; lambda [ 3 ] = 0.0 ; * status = 1 ; r [ 0 ] = 0.0 ; r [ 1 ] = 0.0 ; r [ 2 ] = 0.0 ; rMin = 0.0 ; cTolComputed = false ; cTol [ 0 ] = 1.0 ; iC [ 0 ] = 0 ; cTol [ 1 ] = 1.0 ; iC [ 1 ] = 0 ; cTol [ 2 ] = 1.0 ; iC [ 2 ] = 0 ; cTol [ 3 ] = 1.0 ; iC [ 3 ] = 0 ; nA = 0 ; if ( iA [ 0 ] ) { nA = 1 ; iC [ 0 ] = 1 ; } if ( iA [ 1 ] ) { nA ++ ; iC [ nA - 1 ] = 2 ; } if ( iA [ 2 ] ) { nA ++ ; iC [ nA - 1 ] = 3 ; } if ( iA [ 3 ] ) { nA ++ ; iC [ nA - 1 ] = 4 ; } guard1 = false ; if ( nA > 0 ) { for ( kNext = 0 ; kNext < 6 ; kNext ++ ) { Opt [ kNext ] = 0.0 ; } Rhs [ 0 ] = f [ 0 ] ; Rhs [ 3 ] = 0.0 ; Rhs [ 1 ] = f [ 1 ] ; Rhs [ 4 ] = 0.0 ; Rhs [ 2 ] = f [ 2 ] ; Rhs [ 5 ] = 0.0 ; DualFeasible = false ; ColdReset = false ; do { exitg3 = 0 ; if ( ( ! DualFeasible ) && ( nA > 0 ) && ( * status <= maxiter ) ) { Xnorm0 = d51qh1ev1z ( b_Ac , iC , nA , b_Linv , RLinv , b_D , b_H ) ; if ( Xnorm0 < 0.0 ) { if ( ColdReset ) { * status = - 2 ; exitg3 = 2 ; } else { nA = 0 ; iA [ 0 ] = false ; iC [ 0 ] = 0 ; iA [ 1 ] = false ; iC [ 1 ] = 0 ; iA [ 2 ] = false ; iC [ 2 ] = 0 ; iA [ 3 ] = false ; iC [ 3 ] = 0 ; ColdReset = true ; } } else { for ( kNext = 0 ; kNext < nA ; kNext ++ ) { Rhs [ kNext + 3 ] = b [ iC [ kNext ] - 1 ] ; for ( kDrop = kNext + 1 ; kDrop <= nA ; kDrop ++ ) { U [ ( kDrop + 3 * kNext ) - 1 ] = 0.0 ; for ( iSave = 0 ; iSave < nA ; iSave ++ ) { U [ ( kDrop + 3 * kNext ) - 1 ] += RLinv [ ( 3 * iSave + kDrop ) - 1 ] * RLinv [ 3 * iSave + kNext ] ; } U [ kNext + 3 * ( kDrop - 1 ) ] = U [ ( 3 * kNext + kDrop ) - 1 ] ; } } for ( kNext = 0 ; kNext < 3 ; kNext ++ ) { Opt [ kNext ] = ( b_H [ kNext + 3 ] * Rhs [ 1 ] + b_H [ kNext ] * Rhs [ 0 ] ) + b_H [ kNext + 6 ] * Rhs [ 2 ] ; for ( kDrop = 0 ; kDrop < nA ; kDrop ++ ) { Opt [ kNext ] += b_D [ 3 * kDrop + kNext ] * Rhs [ kDrop + 3 ] ; } } for ( kNext = 0 ; kNext < nA ; kNext ++ ) { Opt [ kNext + 3 ] = ( b_D [ 3 * kNext + 1 ] * Rhs [ 1 ] + b_D [ 3 * kNext ] * Rhs [ 0 ] ) + b_D [ 3 * kNext + 2 ] * Rhs [ 2 ] ; for ( kDrop = 0 ; kDrop < nA ; kDrop ++ ) { Opt [ kNext + 3 ] += U [ 3 * kDrop + kNext ] * Rhs [ kDrop + 3 ] ; } } Xnorm0 = - 1.0E-12 ; kDrop = - 1 ; for ( kNext = 0 ; kNext < nA ; kNext ++ ) { cMin = Opt [ kNext + 3 ] ; lambda [ iC [ kNext ] - 1 ] = cMin ; if ( ( cMin < Xnorm0 ) && ( kNext + 1 <= nA ) ) { kDrop = kNext ; Xnorm0 = cMin ; } } if ( kDrop + 1 <= 0 ) { DualFeasible = true ; x [ 0 ] = Opt [ 0 ] ; x [ 1 ] = Opt [ 1 ] ; x [ 2 ] = Opt [ 2 ] ; } else { ( * status ) ++ ; if ( * status > 5 ) { nA = 0 ; iA [ 0 ] = false ; iC [ 0 ] = 0 ; iA [ 1 ] = false ; iC [ 1 ] = 0 ; iA [ 2 ] = false ; iC [ 2 ] = 0 ; iA [ 3 ] = false ; iC [ 3 ] = 0 ; ColdReset = true ; } else { lambda [ iC [ kDrop ] - 1 ] = 0.0 ; enofia1dwu ( kDrop + 1 , iA , & nA , iC ) ; } } } } else { if ( nA <= 0 ) { lambda [ 0 ] = 0.0 ; lambda [ 1 ] = 0.0 ; lambda [ 2 ] = 0.0 ; lambda [ 3 ] = 0.0 ; Xnorm0 = f [ 1 ] ; cMin = f [ 0 ] ; cVal = f [ 2 ] ; for ( kNext = 0 ; kNext < 3 ; kNext ++ ) { x [ kNext ] = ( - b_Hinv [ kNext + 3 ] * Xnorm0 + - b_Hinv [ kNext ] * cMin ) + - b_Hinv [ kNext + 6 ] * cVal ; } } exitg3 = 1 ; } } while ( exitg3 == 0 ) ; if ( exitg3 == 1 ) { guard1 = true ; } } else { Xnorm0 = f [ 1 ] ; cMin = f [ 0 ] ; cVal = f [ 2 ] ; for ( kNext = 0 ; kNext < 3 ; kNext ++ ) { x [ kNext ] = ( - b_Hinv [ kNext + 3 ] * Xnorm0 + - b_Hinv [ kNext ] * cMin ) + - b_Hinv [ kNext + 6 ] * cVal ; } guard1 = true ; } if ( guard1 ) { Xnorm0 = olmmnsphgv ( x ) ; exitg2 = false ; while ( ( ! exitg2 ) && ( * status <= maxiter ) ) { cMin = - FeasTol ; kNext = - 1 ; for ( kDrop = 0 ; kDrop < 4 ; kDrop ++ ) { if ( ! cTolComputed ) { z [ 0 ] = muDoubleScalarAbs ( b_Ac [ kDrop ] * x [ 0 ] ) ; z [ 1 ] = muDoubleScalarAbs ( b_Ac [ kDrop + 4 ] * x [ 1 ] ) ; z [ 2 ] = muDoubleScalarAbs ( b_Ac [ kDrop + 8 ] * x [ 2 ] ) ; cTol [ kDrop ] = muDoubleScalarMax ( cTol [ kDrop ] , hdev2on2e4 ( z ) ) ; } if ( ! iA [ kDrop ] ) { cVal = ( ( ( b_Ac [ kDrop + 4 ] * x [ 1 ] + b_Ac [ kDrop ] * x [ 0 ] ) + b_Ac [ kDrop + 8 ] * x [ 2 ] ) - b [ kDrop ] ) / cTol [ kDrop ] ; if ( cVal < cMin ) { cMin = cVal ; kNext = kDrop ; } } } cTolComputed = true ; if ( kNext + 1 <= 0 ) { exitg2 = true ; } else if ( * status == maxiter ) { * status = 0 ; exitg2 = true ; } else { do { exitg1 = 0 ; if ( ( kNext + 1 > 0 ) && ( * status <= maxiter ) ) { guard2 = false ; if ( nA == 0 ) { for ( kDrop = 0 ; kDrop < 3 ; kDrop ++ ) { z [ kDrop ] = ( b_Hinv [ kDrop + 3 ] * b_Ac [ kNext + 4 ] + b_Hinv [ kDrop ] * b_Ac [ kNext ] ) + b_Hinv [ kDrop + 6 ] * b_Ac [ kNext + 8 ] ; } guard2 = true ; } else { cMin = d51qh1ev1z ( b_Ac , iC , nA , b_Linv , RLinv , b_D , b_H ) ; if ( cMin <= 0.0 ) { * status = - 2 ; exitg1 = 1 ; } else { for ( kDrop = 0 ; kDrop < 9 ; kDrop ++ ) { U [ kDrop ] = - b_H [ kDrop ] ; } for ( kDrop = 0 ; kDrop < 3 ; kDrop ++ ) { z [ kDrop ] = ( U [ kDrop + 3 ] * b_Ac [ kNext + 4 ] + U [ kDrop ] * b_Ac [ kNext ] ) + U [ kDrop + 6 ] * b_Ac [ kNext + 8 ] ; } for ( kDrop = 0 ; kDrop < nA ; kDrop ++ ) { r [ kDrop ] = ( b_D [ 3 * kDrop + 1 ] * b_Ac [ kNext + 4 ] + b_D [ 3 * kDrop ] * b_Ac [ kNext ] ) + b_D [ 3 * kDrop + 2 ] * b_Ac [ kNext + 8 ] ; } guard2 = true ; } } if ( guard2 ) { kDrop = 0 ; cMin = 0.0 ; DualFeasible = true ; ColdReset = true ; if ( nA > 0 ) { iSave = 0 ; exitg4 = false ; while ( ( ! exitg4 ) && ( iSave <= nA - 1 ) ) { if ( r [ iSave ] >= 1.0E-12 ) { ColdReset = false ; exitg4 = true ; } else { iSave ++ ; } } } if ( ( nA != 0 ) && ( ! ColdReset ) ) { for ( iSave = 0 ; iSave < nA ; iSave ++ ) { cVal = r [ iSave ] ; if ( cVal > 1.0E-12 ) { cVal = lambda [ iC [ iSave ] - 1 ] / cVal ; if ( ( kDrop == 0 ) || ( cVal < rMin ) ) { rMin = cVal ; kDrop = iSave + 1 ; } } } if ( kDrop > 0 ) { cMin = rMin ; DualFeasible = false ; } } b_Ac_p [ 0 ] = b_Ac [ kNext ] ; b_Ac_p [ 1 ] = b_Ac [ kNext + 4 ] ; b_Ac_p [ 2 ] = b_Ac [ kNext + 8 ] ; cVal = c5g5wyzkzq ( z , b_Ac_p ) ; if ( cVal <= 0.0 ) { cVal = 0.0 ; ColdReset = true ; } else { cVal = ( b [ kNext ] - ( ( b_Ac [ kNext + 4 ] * x [ 1 ] + b_Ac [ kNext ] * x [ 0 ] ) + b_Ac [ kNext + 8 ] * x [ 2 ] ) ) / cVal ; ColdReset = false ; } if ( DualFeasible && ColdReset ) { * status = - 1 ; exitg1 = 1 ; } else { if ( ColdReset ) { t = cMin ; } else if ( DualFeasible ) { t = cVal ; } else if ( cMin < cVal ) { t = cMin ; } else { t = cVal ; } for ( iSave = 0 ; iSave < nA ; iSave ++ ) { iC_p = iC [ iSave ] ; lambda [ iC_p - 1 ] -= t * r [ iSave ] ; if ( ( iC_p <= 4 ) && ( lambda [ iC_p - 1 ] < 0.0 ) ) { lambda [ iC_p - 1 ] = 0.0 ; } } lambda [ kNext ] += t ; frexp ( 1.0 , & exponent ) ; if ( muDoubleScalarAbs ( t - cMin ) < 2.2204460492503131E-16 ) { enofia1dwu ( kDrop , iA , & nA , iC ) ; } if ( ! ColdReset ) { x [ 0 ] += t * z [ 0 ] ; x [ 1 ] += t * z [ 1 ] ; x [ 2 ] += t * z [ 2 ] ; frexp ( 1.0 , & b_exponent ) ; if ( muDoubleScalarAbs ( t - cVal ) < 2.2204460492503131E-16 ) { if ( nA == eb1sgplrpe ) { * status = - 1 ; exitg1 = 1 ; } else { nA ++ ; iC [ nA - 1 ] = kNext + 1 ; kDrop = nA - 1 ; while ( ( kDrop + 1 > 1 ) && ( ! ( iC [ kDrop ] > iC [ kDrop - 1 ] ) ) ) { iSave = iC [ kDrop ] ; iC [ kDrop ] = iC [ kDrop - 1 ] ; iC [ kDrop - 1 ] = iSave ; kDrop -- ; } iA [ kNext ] = true ; kNext = - 1 ; ( * status ) ++ ; } } else { ( * status ) ++ ; } } else { ( * status ) ++ ; } } } } else { cMin = olmmnsphgv ( x ) ; if ( muDoubleScalarAbs ( cMin - Xnorm0 ) > 0.001 ) { Xnorm0 = cMin ; cTol [ 0 ] = muDoubleScalarMax ( muDoubleScalarAbs ( b [ 0 ] ) , 1.0 ) ; cTol [ 1 ] = muDoubleScalarMax ( muDoubleScalarAbs ( b [ 1 ] ) , 1.0 ) ; cTol [ 2 ] = muDoubleScalarMax ( muDoubleScalarAbs ( b [ 2 ] ) , 1.0 ) ; cTol [ 3 ] = muDoubleScalarMax ( muDoubleScalarAbs ( b [ 3 ] ) , 1.0 ) ; cTolComputed = false ; } exitg1 = 2 ; } } while ( exitg1 == 0 ) ; if ( exitg1 == 1 ) { exitg2 = true ; } } } } } static void kaaxjzuhhx ( const real_T rseq [ 20 ] , const real_T vseq [ 22 ] , real_T umin , real_T umax , int32_T switch_in , const real_T x [ 5 ] , real_T old_u , const boolean_T iA [ 4 ] , const real_T b_Mlim [ 4 ] , const real_T b_Mx [ 20 ] , const real_T b_Mu1 [ 4 ] , const real_T b_Mv [ 88 ] , const real_T b_utarget [ 10 ] , real_T b_uoff , int32_T b_enable_value , const real_T b_Ac [ 12 ] , const real_T b_A [ 25 ] , const real_T Bu [ 55 ] , const real_T Bv [ 110 ] , const real_T b_C [ 10 ] , const real_T Dv [ 44 ] , real_T * u , real_T useq [ 11 ] , real_T * status , boolean_T iAout [ 4 ] ) { real_T c_Hv [ 440 ] ; real_T Su [ 200 ] ; real_T c_Sx [ 100 ] ; real_T CA_p [ 44 ] ; real_T Su_p [ 40 ] ; real_T c_Kr [ 40 ] ; real_T Sum_p [ 20 ] ; real_T c_Kut [ 20 ] ; real_T c_Su1 [ 20 ] ; real_T CA [ 10 ] ; real_T CA_e [ 10 ] ; real_T L [ 9 ] ; real_T b_H [ 9 ] ; real_T Bc [ 4 ] ; real_T a__1 [ 4 ] ; real_T varargin_1 [ 3 ] ; real_T zopt [ 3 ] ; real_T Sum [ 2 ] ; real_T Bc_p ; real_T b_Mlim_p ; real_T b_Mv_p ; real_T normH ; real_T s ; int32_T Tries ; int32_T i ; int32_T i1 ; int32_T i_p ; int8_T a [ 100 ] ; int8_T b [ 9 ] ; int8_T rows [ 2 ] ; int8_T kidx ; int8_T rows_p ; boolean_T umax_incr_flag ; boolean_T umin_incr_flag ; static const real_T c [ 9 ] = { 2837.6517780966979 , 2138.1106716909467 , 0.0 , 2138.1106716909467 , 1617.4065812047668 , 0.0 , 0.0 , 0.0 , 100000.0 } ; static const int8_T c_A [ 100 ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; static const int8_T c_b [ 20 ] = { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static const int8_T b_Mrows [ 4 ] = { 41 , 42 , 51 , 52 } ; boolean_T exitg1 ; boolean_T exitg2 ; boolean_T guard1 ; boolean_T guard2 ; memcpy ( & b_H [ 0 ] , & c [ 0 ] , 9U * sizeof ( real_T ) ) ; memset ( & useq [ 0 ] , 0 , 11U * sizeof ( real_T ) ) ; * status = 1.0 ; iAout [ 0 ] = false ; iAout [ 1 ] = false ; iAout [ 2 ] = false ; iAout [ 3 ] = false ; if ( switch_in != b_enable_value ) { * u = old_u + b_uoff ; for ( i = 0 ; i < 11 ; i ++ ) { useq [ i ] = * u ; } } else { for ( i1 = 0 ; i1 < 2 ; i1 ++ ) { Sum [ i1 ] = 0.0 ; for ( Tries = 0 ; Tries < 5 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 5 ; i_p ++ ) { normH += b_C [ ( i_p << 1 ) + i1 ] * b_A [ 5 * Tries + i_p ] ; } CA [ i1 + ( Tries << 1 ) ] = normH ; Sum [ i1 ] += b_C [ ( Tries << 1 ) + i1 ] * Bu [ Tries ] ; } for ( Tries = 0 ; Tries < 2 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 5 ; i_p ++ ) { normH += b_C [ ( i_p << 1 ) + i1 ] * Bv [ 5 * Tries + i_p ] ; } Bc [ i1 + ( Tries << 1 ) ] = normH ; } } c_Hv [ 0 ] = Bc [ 0 ] ; c_Hv [ 40 ] = Dv [ 0 ] ; c_Hv [ 1 ] = Bc [ 1 ] ; c_Hv [ 41 ] = Dv [ 1 ] ; c_Hv [ 20 ] = Bc [ 2 ] ; c_Hv [ 60 ] = Dv [ 2 ] ; c_Hv [ 21 ] = Bc [ 3 ] ; c_Hv [ 61 ] = Dv [ 3 ] ; for ( i1 = 0 ; i1 < 18 ; i1 ++ ) { c_Hv [ 20 * ( i1 + 4 ) ] = 0.0 ; c_Hv [ 20 * ( i1 + 4 ) + 1 ] = 0.0 ; } for ( i1 = 0 ; i1 < 22 ; i1 ++ ) { memset ( & c_Hv [ i1 * 20 + 2 ] , 0 , 18U * sizeof ( real_T ) ) ; } for ( i1 = 0 ; i1 < 5 ; i1 ++ ) { c_Sx [ 20 * i1 ] = CA [ i1 << 1 ] ; c_Sx [ 20 * i1 + 1 ] = CA [ ( i1 << 1 ) + 1 ] ; memset ( & c_Sx [ i1 * 20 + 2 ] , 0 , 18U * sizeof ( real_T ) ) ; } c_Su1 [ 0 ] = Sum [ 0 ] ; c_Su1 [ 1 ] = Sum [ 1 ] ; memset ( & c_Su1 [ 2 ] , 0 , 18U * sizeof ( real_T ) ) ; Su [ 0 ] = Sum [ 0 ] ; Su [ 1 ] = Sum [ 1 ] ; for ( i1 = 0 ; i1 < 9 ; i1 ++ ) { Su [ 20 * ( i1 + 1 ) ] = 0.0 ; Su [ 20 * ( i1 + 1 ) + 1 ] = 0.0 ; } for ( i1 = 0 ; i1 < 10 ; i1 ++ ) { memset ( & Su [ i1 * 20 + 2 ] , 0 , 18U * sizeof ( real_T ) ) ; } for ( i = 0 ; i < 9 ; i ++ ) { kidx = ( int8_T ) ( ( ( i + 1 ) << 1 ) + 1 ) ; for ( i1 = 0 ; i1 < 2 ; i1 ++ ) { rows_p = ( int8_T ) ( i1 + kidx ) ; rows [ i1 ] = rows_p ; Bc_p = 0.0 ; for ( Tries = 0 ; Tries < 5 ; Tries ++ ) { Bc_p += CA [ ( Tries << 1 ) + i1 ] * Bu [ Tries ] ; } normH = Sum [ i1 ] + Bc_p ; Sum [ i1 ] = normH ; c_Su1 [ rows_p - 1 ] = normH ; Sum_p [ i1 ] = normH ; } rows_p = rows [ 0 ] ; kidx = rows [ 1 ] ; for ( i1 = 0 ; i1 < 9 ; i1 ++ ) { Sum_p [ ( i1 + 1 ) << 1 ] = Su [ ( 20 * i1 + rows_p ) - 3 ] ; Sum_p [ ( ( i1 + 1 ) << 1 ) + 1 ] = Su [ ( 20 * i1 + kidx ) - 3 ] ; } rows_p = rows [ 0 ] ; kidx = rows [ 1 ] ; for ( i1 = 0 ; i1 < 10 ; i1 ++ ) { Su [ ( rows_p + 20 * i1 ) - 1 ] = Sum_p [ i1 << 1 ] ; Su [ ( kidx + 20 * i1 ) - 1 ] = Sum_p [ ( i1 << 1 ) + 1 ] ; } for ( i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( Tries = 0 ; Tries < 2 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 5 ; i_p ++ ) { normH += CA [ ( i_p << 1 ) + i1 ] * Bv [ 5 * Tries + i_p ] ; } Bc [ i1 + ( Tries << 1 ) ] = normH ; } } CA_p [ 0 ] = Bc [ 0 ] ; CA_p [ 1 ] = Bc [ 1 ] ; CA_p [ 2 ] = Bc [ 2 ] ; CA_p [ 3 ] = Bc [ 3 ] ; rows_p = rows [ 0 ] ; kidx = rows [ 1 ] ; for ( i1 = 0 ; i1 < 20 ; i1 ++ ) { CA_p [ ( i1 + 2 ) << 1 ] = c_Hv [ ( 20 * i1 + rows_p ) - 3 ] ; CA_p [ ( ( i1 + 2 ) << 1 ) + 1 ] = c_Hv [ ( 20 * i1 + kidx ) - 3 ] ; } rows_p = rows [ 0 ] ; kidx = rows [ 1 ] ; for ( i1 = 0 ; i1 < 22 ; i1 ++ ) { c_Hv [ ( rows_p + 20 * i1 ) - 1 ] = CA_p [ i1 << 1 ] ; c_Hv [ ( kidx + 20 * i1 ) - 1 ] = CA_p [ ( i1 << 1 ) + 1 ] ; } for ( i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( Tries = 0 ; Tries < 5 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 5 ; i_p ++ ) { normH += CA [ ( i_p << 1 ) + i1 ] * b_A [ 5 * Tries + i_p ] ; } CA_e [ i1 + ( Tries << 1 ) ] = normH ; } } memcpy ( & CA [ 0 ] , & CA_e [ 0 ] , 10U * sizeof ( real_T ) ) ; rows_p = rows [ 0 ] ; kidx = rows [ 1 ] ; for ( i1 = 0 ; i1 < 5 ; i1 ++ ) { c_Sx [ ( rows_p + 20 * i1 ) - 1 ] = CA [ i1 << 1 ] ; c_Sx [ ( kidx + 20 * i1 ) - 1 ] = CA [ ( i1 << 1 ) + 1 ] ; } } i = - 1 ; for ( Tries = 0 ; Tries < 10 ; Tries ++ ) { for ( i1 = 0 ; i1 < 10 ; i1 ++ ) { a [ ( i + i1 ) + 1 ] = c_A [ 10 * Tries + i1 ] ; } i += 10 ; } for ( i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( Tries = 0 ; Tries < 20 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 10 ; i_p ++ ) { normH += Su [ 20 * i_p + Tries ] * ( real_T ) c_b [ 10 * i1 + i_p ] ; } Su_p [ Tries + 20 * i1 ] = normH ; } for ( Tries = 0 ; Tries < 10 ; Tries ++ ) { normH = 0.0 ; for ( i_p = 0 ; i_p < 10 ; i_p ++ ) { normH += ( real_T ) ( a [ 10 * i_p + Tries ] * c_b [ 10 * i1 + i_p ] ) ; } Sum_p [ Tries + 10 * i1 ] = normH ; } } cmw0kwnpvh ( Su_p , Sum_p , c_Su1 , c_Sx , c_Hv , Bc , Sum , c_Kut , CA , CA_p , c_Kr ) ; b_H [ 0 ] = Bc [ 0 ] ; b_H [ 1 ] = Bc [ 1 ] ; b_H [ 3 ] = Bc [ 2 ] ; b_H [ 4 ] = Bc [ 3 ] ; i = 0 ; memcpy ( & L [ 0 ] , & b_H [ 0 ] , 9U * sizeof ( real_T ) ) ; Tries = jqw0p1kzpa ( L ) ; guard1 = false ; if ( Tries == 0 ) { varargin_1 [ 0 ] = L [ 0 ] ; varargin_1 [ 1 ] = L [ 4 ] ; varargin_1 [ 2 ] = L [ 8 ] ; if ( cxe2vkg4wi ( varargin_1 ) > 1.4901161193847656E-7 ) { } else { guard1 = true ; } } else { guard1 = true ; } if ( guard1 ) { normH = 0.0 ; Tries = 0 ; exitg2 = false ; while ( ( ! exitg2 ) && ( Tries < 3 ) ) { s = ( muDoubleScalarAbs ( b_H [ Tries + 3 ] ) + muDoubleScalarAbs ( b_H [ Tries ] ) ) + b_H [ Tries + 6 ] ; if ( muDoubleScalarIsNaN ( s ) ) { normH = ( rtNaN ) ; exitg2 = true ; } else { if ( s > normH ) { normH = s ; } Tries ++ ; } } if ( normH >= 1.0E+10 ) { i = 2 ; } else { Tries = 0 ; exitg1 = false ; while ( ( ! exitg1 ) && ( Tries <= 4 ) ) { normH = muDoubleScalarPower ( 10.0 , Tries ) * 1.4901161193847656E-7 ; for ( i1 = 0 ; i1 < 9 ; i1 ++ ) { b [ i1 ] = 0 ; } b [ 0 ] = 1 ; b [ 4 ] = 1 ; b [ 8 ] = 1 ; for ( i1 = 0 ; i1 < 9 ; i1 ++ ) { s = normH * ( real_T ) b [ i1 ] + b_H [ i1 ] ; b_H [ i1 ] = s ; L [ i1 ] = s ; } i = jqw0p1kzpa ( L ) ; guard2 = false ; if ( i == 0 ) { varargin_1 [ 0 ] = L [ 0 ] ; varargin_1 [ 1 ] = L [ 4 ] ; varargin_1 [ 2 ] = L [ 8 ] ; if ( cxe2vkg4wi ( varargin_1 ) > 1.4901161193847656E-7 ) { i = 1 ; exitg1 = true ; } else { guard2 = true ; } } else { guard2 = true ; } if ( guard2 ) { i = 3 ; Tries ++ ; } } } } if ( i > 1 ) { * u = old_u + b_uoff ; for ( i = 0 ; i < 11 ; i ++ ) { useq [ i ] = * u ; } * status = - 2.0 ; } else { for ( i1 = 0 ; i1 < 9 ; i1 ++ ) { b [ i1 ] = 0 ; } b [ 0 ] = 1 ; b [ 4 ] = 1 ; b [ 8 ] = 1 ; for ( i = 0 ; i < 3 ; i ++ ) { b_H [ 3 * i ] = b [ 3 * i ] ; b_H [ 3 * i + 1 ] = b [ 3 * i + 1 ] ; b_H [ 3 * i + 2 ] = b [ 3 * i + 2 ] ; } jylmeeyvqk ( L , b_H ) ; umax_incr_flag = false ; normH = 0.0 ; umin_incr_flag = false ; s = 0.0 ; for ( i = 0 ; i < 4 ; i ++ ) { Bc_p = 0.0 ; for ( i1 = 0 ; i1 < 5 ; i1 ++ ) { Bc_p += b_Mx [ ( i1 << 2 ) + i ] * x [ i1 ] ; } b_Mlim_p = b_Mlim [ i ] ; b_Mv_p = 0.0 ; for ( i1 = 0 ; i1 < 22 ; i1 ++ ) { b_Mv_p += b_Mv [ ( i1 << 2 ) + i ] * vseq [ i1 ] ; } Bc_p = - ( ( ( b_Mlim_p + Bc_p ) + b_Mu1 [ i ] * old_u ) + b_Mv_p ) ; Bc [ i ] = Bc_p ; if ( b_Mrows [ i ] <= 50 ) { if ( ! umax_incr_flag ) { normH = - ( umax - b_uoff ) - ( - b_Mlim_p ) ; umax_incr_flag = true ; } Bc [ i ] = Bc_p + normH ; } else { if ( ! umin_incr_flag ) { s = ( umin - b_uoff ) - ( - b_Mlim_p ) ; umin_incr_flag = true ; } Bc [ i ] = Bc_p + s ; } } varargin_1 [ 0 ] = 0.0 ; varargin_1 [ 1 ] = 0.0 ; varargin_1 [ 2 ] = 0.0 ; for ( i = 0 ; i < 2 ; i ++ ) { normH = 0.0 ; for ( i1 = 0 ; i1 < 5 ; i1 ++ ) { normH += CA [ 5 * i + i1 ] * x [ i1 ] ; } s = 0.0 ; for ( i1 = 0 ; i1 < 20 ; i1 ++ ) { s += c_Kr [ 20 * i + i1 ] * rseq [ i1 ] ; } b_Mlim_p = 0.0 ; for ( i1 = 0 ; i1 < 22 ; i1 ++ ) { b_Mlim_p += CA_p [ 22 * i + i1 ] * vseq [ i1 ] ; } Bc_p = 0.0 ; for ( i1 = 0 ; i1 < 10 ; i1 ++ ) { Bc_p += c_Kut [ 10 * i + i1 ] * b_utarget [ i1 ] ; } varargin_1 [ i ] = ( ( ( normH + s ) + Sum [ i ] * old_u ) + b_Mlim_p ) + Bc_p ; } iAout [ 0 ] = iA [ 0 ] ; iAout [ 1 ] = iA [ 1 ] ; iAout [ 2 ] = iA [ 2 ] ; iAout [ 3 ] = iA [ 3 ] ; for ( i1 = 0 ; i1 < 3 ; i1 ++ ) { for ( Tries = 0 ; Tries < 3 ; Tries ++ ) { L [ i1 + 3 * Tries ] = ( b_H [ 3 * i1 + 1 ] * b_H [ 3 * Tries + 1 ] + b_H [ 3 * i1 ] * b_H [ 3 * Tries ] ) + b_H [ 3 * i1 + 2 ] * b_H [ 3 * Tries + 2 ] ; } } fhzpmegedn ( b_H , L , varargin_1 , b_Ac , Bc , iAout , 120 , 1.0E-6 , zopt , a__1 , & i ) ; if ( ( i < 0 ) || ( i == 0 ) ) { zopt [ 0 ] = 0.0 ; } * status = i ; * u = ( old_u + zopt [ 0 ] ) + b_uoff ; } } } void MdlInitialize ( void ) { int32_T i ; rtX . fivs40guhu = rtP . e1_initial ; for ( i = 0 ; i < 5 ; i ++ ) { rtDW . mwdhrz5xb1 [ i ] = rtP . last_x_InitialCondition [ i ] ; } rtDW . j45svihtjo = rtP . last_mv_InitialCondition ; rtX . obmuwhiu30 = rtP . e2_initial ; rtDW . oen24533b2 = rtP . Memory1_InitialCondition ; memcpy ( & rtDW . kwh42zszzd [ 0 ] , & rtP . LastPcov_InitialCondition [ 0 ] , 25U * sizeof ( real_T ) ) ; rtDW . pswc1mgssa [ 0 ] = rtP . Memory_InitialCondition [ 0 ] ; rtDW . pswc1mgssa [ 1 ] = rtP . Memory_InitialCondition [ 1 ] ; rtDW . pswc1mgssa [ 2 ] = rtP . Memory_InitialCondition [ 2 ] ; rtDW . pswc1mgssa [ 3 ] = rtP . Memory_InitialCondition [ 3 ] ; rtX . ntspwlarvq = rtP . Vy_IC ; rtX . jbfykaxbhu = rtP . Yaw_rate_IC ; i1fgdxmeff ( & rtDW . k1mx4005qx ) ; i1fgdxmeff ( & rtDW . gnys0rptin ) ; rtDW . bjss44da1o = false ; rtDW . evq0kveuwk = jbznyvk4nl ; rtDW . eav1tlopa2 = false ; rtDW . fwdhnrc1pz = jbznyvk4nl ; mgzh2u4e23 ( & rtDW . gccus3jafp ) ; mgzh2u4e23 ( & rtDW . bk3nxv3tlr ) ; mgzh2u4e23 ( & rtDW . cc1fon30yl ) ; rtDW . axawio3aws = false ; rtDW . j0i5djvvgw = jbznyvk4nl ; mgzh2u4e23 ( & rtDW . njn5yczmu3 ) ; mgzh2u4e23 ( & rtDW . euyeijkvwj ) ; mgzh2u4e23 ( & rtDW . elsnrsfkpu ) ; mgzh2u4e23 ( & rtDW . lzaj2qo24h ) ; mgzh2u4e23 ( & rtDW . kug2oixzkm ) ; mgzh2u4e23 ( & rtDW . gnn330lieg ) ; mgzh2u4e23 ( & rtDW . e5mwwrj2xv ) ; mgzh2u4e23 ( & rtDW . be3jllceim ) ; rtDW . hgfwy0uny1 = false ; rtDW . e51nkuwvdf = jbznyvk4nl ; rtDW . byo3k50uq4 = false ; rtDW . oikgzdquty = jbznyvk4nl ; mgzh2u4e23 ( & rtDW . cik2vkh3a4 ) ; fcfdecnkl3 ( & rtDW . gqjzh0f3es ) ; rtDW . b5dfi4px0f = false ; rtDW . h4zkufiov3 = jbznyvk4nl ; fcfdecnkl3 ( & rtDW . cvyjidmo4f ) ; } void MdlStart ( void ) { { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "steering_angle" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "steering_angle" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "LKA_T_staliro/Subsystem/Lane Keeping Assist System" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "steering_angle" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_DISCRETE ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . kz0usvbqfo . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "94d76f8b-003f-4223-bb6a-8e0ad6c1d491" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . kz0usvbqfo . AQHandles , hDT , & srcInfo ) ; if ( rtDW . kz0usvbqfo . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . kz0usvbqfo . AQHandles , "0.1" , 0.1 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . kz0usvbqfo . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . kz0usvbqfo . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . kz0usvbqfo . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . kz0usvbqfo . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "lateral_deviation" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "lateral_deviation" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "LKA_T_staliro/Subsystem/Sensor Dynamics" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "lateral_deviation" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 0 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . h35e1w25qj . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "5de939c3-ce91-41b1-bfe7-fa8e6534dba9" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . h35e1w25qj . AQHandles , hDT , & srcInfo ) ; if ( rtDW . h35e1w25qj . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . h35e1w25qj . AQHandles , "0.1" , 0.1 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . h35e1w25qj . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . h35e1w25qj . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . h35e1w25qj . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . h35e1w25qj . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } { { { bool isStreamoutAlreadyRegistered = false ; { sdiSignalSourceInfoU srcInfo ; sdiLabelU loggedName = sdiGetLabelFromChars ( "relative_yaw_angle" ) ; sdiLabelU origSigName = sdiGetLabelFromChars ( "relative_yaw_angle" ) ; sdiLabelU propName = sdiGetLabelFromChars ( "" ) ; sdiLabelU blockPath = sdiGetLabelFromChars ( "LKA_T_staliro/Subsystem/Sensor Dynamics" ) ; sdiLabelU blockSID = sdiGetLabelFromChars ( "" ) ; sdiLabelU subPath = sdiGetLabelFromChars ( "" ) ; sdiDims sigDims ; sdiLabelU sigName = sdiGetLabelFromChars ( "relative_yaw_angle" ) ; sdiAsyncRepoDataTypeHandle hDT = sdiAsyncRepoGetBuiltInDataTypeHandle ( DATA_TYPE_DOUBLE ) ; { sdiComplexity sigComplexity = REAL ; sdiSampleTimeContinuity stCont = SAMPLE_TIME_CONTINUOUS ; int_T sigDimsArray [ 1 ] = { ( int_T ) 1 } ; sigDims . nDims = 1 ; sigDims . dimensions = sigDimsArray ; srcInfo . numBlockPathElems = 1 ; srcInfo . fullBlockPath = ( sdiFullBlkPathU ) & blockPath ; srcInfo . SID = ( sdiSignalIDU ) & blockSID ; srcInfo . subPath = subPath ; srcInfo . portIndex = 1 + 1 ; srcInfo . signalName = sigName ; srcInfo . sigSourceUUID = 0 ; rtDW . a5r4vbzi4b . AQHandles = sdiStartAsyncioQueueCreation ( hDT , & srcInfo , rt_dataMapInfo . mmi . InstanceMap . fullPath , "093b6532-8db4-4b61-9f22-48fcdf5dee11" , sigComplexity , & sigDims , DIMENSIONS_MODE_FIXED , stCont , "" ) ; sdiCompleteAsyncioQueueCreation ( rtDW . a5r4vbzi4b . AQHandles , hDT , & srcInfo ) ; if ( rtDW . a5r4vbzi4b . AQHandles ) { sdiSetSignalSampleTimeString ( rtDW . a5r4vbzi4b . AQHandles , "0.1" , 0.1 , ssGetTFinal ( rtS ) ) ; sdiSetSignalRefRate ( rtDW . a5r4vbzi4b . AQHandles , 0.0 ) ; sdiSetRunStartTime ( rtDW . a5r4vbzi4b . AQHandles , ssGetTaskTime ( rtS , 1 ) ) ; sdiAsyncRepoSetSignalExportSettings ( rtDW . a5r4vbzi4b . AQHandles , 1 , 0 ) ; sdiAsyncRepoSetSignalExportName ( rtDW . a5r4vbzi4b . AQHandles , loggedName , origSigName , propName ) ; } sdiFreeLabel ( sigName ) ; sdiFreeLabel ( loggedName ) ; sdiFreeLabel ( origSigName ) ; sdiFreeLabel ( propName ) ; sdiFreeLabel ( blockPath ) ; sdiFreeLabel ( blockSID ) ; sdiFreeLabel ( subPath ) ; } } if ( ! isStreamoutAlreadyRegistered ) { } } } } MdlInitialize ( ) ; } void MdlOutputs ( int_T tid ) { real_T Bv [ 110 ] ; real_T Cm [ 110 ] ; real_T tmp_m [ 88 ] ; real_T Bu [ 55 ] ; real_T CovMat [ 49 ] ; real_T Dv [ 44 ] ; real_T b_tmp [ 35 ] ; real_T b_B [ 30 ] ; real_T b_A [ 25 ] ; real_T b_A_i [ 25 ] ; real_T b_A_m [ 25 ] ; real_T b_A_p [ 25 ] ; real_T vseq [ 22 ] ; real_T rseq [ 20 ] ; real_T tmp_i [ 20 ] ; real_T Ai [ 16 ] ; real_T a [ 16 ] ; real_T a_p [ 16 ] ; real_T furzsrerqr [ 16 ] ; real_T tmp_p [ 16 ] ; real_T az2sdnjtqb [ 11 ] ; real_T cyalvcgwla [ 11 ] ; real_T L [ 10 ] ; real_T b_A_e [ 10 ] ; real_T b_C [ 10 ] ; real_T b [ 8 ] ; real_T nah5npyaz2 [ 8 ] ; real_T tmp [ 6 ] ; real_T UnknownIn [ 5 ] ; real_T cqnehczjtf [ 5 ] ; real_T lp5v4nuilo [ 5 ] ; real_T Kinv [ 4 ] ; real_T baq5ffy01v [ 4 ] ; real_T c_a [ 4 ] ; real_T tmp_e [ 2 ] ; real_T y_innov [ 2 ] ; real_T Referenceconstant_Value ; real_T U_idx_0 ; real_T U_idx_1 ; real_T Y_idx_0 ; real_T Y_idx_1 ; real_T a22 ; real_T jx5vcee1jt ; real_T pcdjaqurn1 ; int32_T Coef ; int32_T i ; int32_T r2 ; int8_T Dvm [ 44 ] ; int8_T b_D [ 12 ] ; int8_T c_B [ 4 ] ; int8_T c_a_e ; int8_T c_a_i ; int8_T c_a_p ; SimStruct * S ; void * diag ; static const real_T b_p [ 152 ] = { 0.00026400512930369264 , 0.00041550590044650554 , 0.00060873933441222021 , 0.00069802046220211506 , 0.00079962701010072681 , 0.00091500877095580108 , 0.0010457009576705161 , 0.0011932969129860706 , 0.0013594058314574699 , 0.0015455909004565814 , 0.0017532824073029673 , 0.001983659575079033 , 0.0022374943503646388 , 0.002514950335411441 , 0.0028153309161201017 , 0.0031367728990405247 , 0.0034758862711418985 , 0.00382734773248662 , 0.0041834660378559626 , 0.0045337511833617285 , 0.0048645365973009353 , 0.0051587219787842722 , 0.0053957207450854071 , 0.00555170471067141 , 0.0056002327008140423 , 0.0055133226032859561 , 0.0052629743545930911 , 0.0048230777873180157 , 0.0041715567990525471 , 0.0032925314254311027 , 0.0021782468517576024 , 0.00083054134815533124 , - 0.00073829492418545789 , - 0.0025053008794805351 , - 0.004437176478624425 , - 0.0064909935871201316 , - 0.008615092738663753 , - 0.010750021768691654 , - 0.012829481113279313 , - 0.014781388359522507 , - 0.016529331642527061 , - 0.01799480333879894 , - 0.019100626428931834 , - 0.019775828285578858 , - 0.019961832560139309 , - 0.019619277342043776 , - 0.018734216724294574 , - 0.017322213949845438 , - 0.015429124131975046 , - 0.013128184420903698 , - 0.010514055481097186 , - 0.0076952063403129987 , - 0.0047861594818428563 , - 0.0019006253194899544 , 0.00085420246902214152 , 0.0033825018920619109 , 0.0056042579874111429 , 0.0074593682035411666 , 0.0089109729066892181 , 0.0099472021996190388 , 0.010580593494912067 , 0.01084492879445044 , 0.010789926030754122 , 0.010474766846443849 , 0.0099616316978769666 , 0.0093102256360866036 , 0.0085738635352473 , 0.0077972384013762852 , 0.0070156626423460286 , 0.0062554006298338868 , 0.0055346806827978878 , 0.0048650331350013429 , 0.0042526963640359 , 0.0036999284374138923 , 0.0032061400245894209 , 0.0027688192008355835 , 0.0023842528103127378 , 0.0020480670994155676 , 0.0017556175641658134 , 0.0015022586512578493 , 0.0012835211834779999 , 0.001095221140575833 , 0.00093351889281204417 , 0.00079494377572881636 , 0.00067639528126607162 , 0.00057512919063608565 , 0.0004887346516541626 , 0.000415106424171233 , 0.00035241518536552579 , 0.00029907780937623788 , 0.00025372883213819287 , 0.00021519381542631116 , 0.00018246498065966089 , 0.00015467925156255417 , 0.000131098693871882 , 0.00011109324637461578 , 9.41255833391379E-5 , 7.9737921251953316E-5 , 6.7540573643696E-5 , 5.7202060237310344E-5 , 4.8440586210366325E-5 , 4.1016720913117724E-5 , 3.4727120860023081E-5 , 2.9399157821983971E-5 , 2.4886328512741172E-5 , 2.1064337191633238E-5 , 1.7827756151088914E-5 , 1.5087181454825147E-5 , 1.276681236577257E-5 , 1.080239271199565E-5 , 9.1394610650030883E-6 , 7.731864112345137E-6 , 6.5404941750967185E-6 , 5.5322174512463553E-6 , 4.6789644422941932E-6 , 3.9569582445107186E-6 , 3.3460599469684905E-6 , 2.8292134832415359E-6 , 2.3919749130238686E-6 , 2.0221133496692989E-6 , 1.7092726868527361E-6 , 1.4446848894878336E-6 , 1.2209270177427317E-6 , 1.0317153368375067E-6 , 8.7173087170671582E-7 , 7.3647161214225548E-7 , 6.2212730746939156E-7 , 5.254734115320109E-7 , 4.4378125055225484E-7 , 3.74741942952136E-7 , 3.164019622069757E-7 , 2.6710857308483043E-7 , 2.2546363097364706E-7 , 1.902844554509129E-7 , 1.6057071030783932E-7 , 1.3547636079607383E-7 , 1.1428593084223381E-7 , 9.6394413438890862E-8 , 8.1290258475144381E-8 , 6.8540974180214137E-8 , 5.778094684195946E-8 , 4.8701127673829028E-8 , 4.1040307744795565E-8 , 3.4577734848220191E-8 , 2.9126868620700967E-8 , 2.4530094498861281E-8 , 2.0654252431817253E-8 , 1.7386858175427147E-8 , 1.4632901507777886E-8 , 9.7420625640633076E-9 , 6.1107184497667976E-9 , 6.1107184497667976E-9 } ; static const int8_T c_a_m [ 6 ] = { 1 , 0 , 0 , 1 , 0 , - 1 } ; static const real_T c [ 25 ] = { 0.6400100441065 , 0.073541353572797175 , 0.084812117446611088 , 0.0042654972132582063 , 0.0 , - 1.1039094163180618 , 0.59853427712220575 , 0.016825252587936237 , 0.079549650904534058 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.8744669929461386 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 } ; static const real_T d [ 30 ] = { 0.96178582149796843 , 1.3646371132524373 , 0.11608137692268933 , 0.0720920787495484 , 0.0 , 0.0 , 0.0 , - 0.00093723349647306946 , - 0.001 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.1 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; static const int8_T e [ 10 ] = { 0 , 0 , 0 , 0 , 2 , 0 , 0 , 10 , 0 , 1 } ; static const int8_T f [ 12 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 } ; static const real_T g [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 0.01 , 0.01 , 0.01 , 0.01 } ; static const int8_T tmp_g [ 8 ] = { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 } ; static const real_T h [ 8 ] = { 0.5 , 0.1 , 0.5 , 0.1 , 0.5 , 0.1 , 0.5 , 0.1 } ; static const real_T t [ 4 ] = { - 1.0 , - 1.0 , 1.0 , 1.0 } ; static const real_T x [ 12 ] = { - 1.0 , - 1.0 , 1.0 , 1.0 , - 0.0 , - 1.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; rtB . jl0aukavwi = rtX . fivs40guhu ; rtY . ggwcqiyygf = rtB . jl0aukavwi ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { for ( i = 0 ; i < 5 ; i ++ ) { cqnehczjtf [ i ] = rtDW . mwdhrz5xb1 [ i ] ; } jx5vcee1jt = rtDW . j45svihtjo ; } ea5jflxydi ( rtB . jl0aukavwi , & rtB . k1mx4005qx , & rtDW . k1mx4005qx ) ; rtB . itiywpghyu = rtX . obmuwhiu30 ; ea5jflxydi ( rtB . itiywpghyu , & rtB . gnys0rptin , & rtDW . gnys0rptin ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . evq0kveuwk = jbznyvk4nl ; for ( Coef = 0 ; Coef < 11 ; Coef ++ ) { if ( ( ( real_T ) Coef + 1.0 ) + rtDW . oen24533b2 > 152.0 ) { az2sdnjtqb [ Coef ] = 6.1107184497667976E-9 ; } else { az2sdnjtqb [ Coef ] = b_p [ ( int32_T ) ( ( ( real_T ) Coef + 1.0 ) + rtDW . oen24533b2 ) - 1 ] ; } } if ( rtDW . oen24533b2 + 1.0 > 152.0 ) { rtB . p42cer33ct = 6.1107184497667976E-9 ; } else { rtB . p42cer33ct = b_p [ ( int32_T ) ( rtDW . oen24533b2 + 1.0 ) - 1 ] ; } rtB . ppw1rz40hr = rtDW . oen24533b2 + 1.0 ; rtDW . fwdhnrc1pz = jbznyvk4nl ; kj444jmrfp ( rtP . Vx , & rtB . gccus3jafp , & rtDW . gccus3jafp ) ; for ( i = 0 ; i < 11 ; i ++ ) { cyalvcgwla [ i ] = az2sdnjtqb [ i ] * rtB . gccus3jafp . onhvape52u ; } kj444jmrfp ( rtP . u_min , & rtB . bk3nxv3tlr , & rtDW . bk3nxv3tlr ) ; kj444jmrfp ( rtP . u_max , & rtB . cc1fon30yl , & rtDW . cc1fon30yl ) ; rtDW . j0i5djvvgw = jbznyvk4nl ; kj444jmrfp ( rtP . Sampletimeconstant_Value , & rtB . njn5yczmu3 , & rtDW . njn5yczmu3 ) ; kj444jmrfp ( rtP . Vehiclereartirecorneringstiffnessconstant_Value , & rtB . euyeijkvwj , & rtDW . euyeijkvwj ) ; kj444jmrfp ( rtP . Vehiclefronttirecorneringstiffnessconstant_Value , & rtB . elsnrsfkpu , & rtDW . elsnrsfkpu ) ; kj444jmrfp ( rtP . Vehiclemassconstant_Value , & rtB . lzaj2qo24h , & rtDW . lzaj2qo24h ) ; kj444jmrfp ( rtP . Vehiclelengthtorearconstant_Value , & rtB . kug2oixzkm , & rtDW . kug2oixzkm ) ; kj444jmrfp ( rtP . Vehiclelengthtofrontconstant_Value , & rtB . gnn330lieg , & rtDW . gnn330lieg ) ; pcdjaqurn1 = ( rtB . gnn330lieg . onhvape52u * rtB . elsnrsfkpu . onhvape52u - rtB . kug2oixzkm . onhvape52u * rtB . euyeijkvwj . onhvape52u ) * rtP . Gain3_Gain ; kj444jmrfp ( rtP . Vehicleyawinertiaconstant_Value , & rtB . e5mwwrj2xv , & rtDW . e5mwwrj2xv ) ; baq5ffy01v [ 0 ] = ( rtB . euyeijkvwj . onhvape52u + rtB . elsnrsfkpu . onhvape52u ) * rtP . Gain2_Gain / rtB . lzaj2qo24h . onhvape52u / rtB . gccus3jafp . onhvape52u ; baq5ffy01v [ 1 ] = pcdjaqurn1 / rtB . gccus3jafp . onhvape52u / rtB . e5mwwrj2xv . onhvape52u ; baq5ffy01v [ 2 ] = pcdjaqurn1 / rtB . gccus3jafp . onhvape52u / rtB . lzaj2qo24h . onhvape52u - rtB . gccus3jafp . onhvape52u ; baq5ffy01v [ 3 ] = ( rtB . kug2oixzkm . onhvape52u * rtB . kug2oixzkm . onhvape52u * rtB . euyeijkvwj . onhvape52u + rtB . gnn330lieg . onhvape52u * rtB . gnn330lieg . onhvape52u * rtB . elsnrsfkpu . onhvape52u ) * rtP . Gain4_Gain / rtB . gccus3jafp . onhvape52u / rtB . e5mwwrj2xv . onhvape52u ; kj444jmrfp ( rtP . LaneKeepingAssistSystem_TransportLag , & rtB . be3jllceim , & rtDW . be3jllceim ) ; rtDW . e51nkuwvdf = jbznyvk4nl ; tmp [ 0 ] = rtP . CmConstant_Value [ 0 ] ; tmp [ 1 ] = rtP . CmConstant_Value [ 1 ] ; tmp [ 2 ] = 0.0 ; tmp [ 3 ] = rtP . CmConstant_Value [ 2 ] ; tmp [ 4 ] = rtP . CmConstant_Value [ 3 ] ; tmp [ 5 ] = 0.0 ; for ( i = 0 ; i < 2 ; i ++ ) { c_a_p = c_a_m [ i + 2 ] ; c_a_e = c_a_m [ i ] ; c_a_i = c_a_m [ i + 4 ] ; for ( r2 = 0 ; r2 < 2 ; r2 ++ ) { c_a [ i + ( r2 << 1 ) ] = ( tmp [ 3 * r2 + 1 ] * ( real_T ) c_a_p + tmp [ 3 * r2 ] * ( real_T ) c_a_e ) + tmp [ 3 * r2 + 2 ] * ( real_T ) c_a_i ; a [ r2 + ( i << 2 ) ] = baq5ffy01v [ ( i << 1 ) + r2 ] ; a [ r2 + ( ( i + 2 ) << 2 ) ] = 0.0 ; } } a [ 10 ] = 0.0 ; a [ 14 ] = rtB . gccus3jafp . onhvape52u ; b [ 0 ] = rtB . elsnrsfkpu . onhvape52u / rtB . lzaj2qo24h . onhvape52u * rtP . Gain_Gain ; b [ 1 ] = rtB . elsnrsfkpu . onhvape52u * rtB . gnn330lieg . onhvape52u / rtB . e5mwwrj2xv . onhvape52u * rtP . Gain1_Gain ; a [ 2 ] = c_a [ 0 ] ; a [ 3 ] = c_a [ 1 ] ; a [ 11 ] = 0.0 ; b [ 4 ] = 0.0 ; a [ 6 ] = c_a [ 2 ] ; a [ 7 ] = c_a [ 3 ] ; a [ 15 ] = 0.0 ; b [ 5 ] = 0.0 ; b [ 2 ] = 0.0 ; b [ 3 ] = 0.0 ; b [ 6 ] = 0.0 ; b [ 7 ] = - 1.0 ; if ( rtB . njn5yczmu3 . onhvape52u > 0.0 ) { for ( i = 0 ; i < 16 ; i ++ ) { a_p [ i ] = a [ i ] * rtB . njn5yczmu3 . onhvape52u ; } mw3hm0er3e ( a_p , furzsrerqr ) ; pcdjaqurn1 = rtB . njn5yczmu3 . onhvape52u / 4.0 ; memset ( & Ai [ 0 ] , 0 , sizeof ( real_T ) << 4U ) ; Ai [ 0 ] = 1.0 ; Ai [ 5 ] = 1.0 ; Ai [ 10 ] = 1.0 ; Ai [ 15 ] = 1.0 ; for ( i = 0 ; i < 16 ; i ++ ) { Ai [ i ] += furzsrerqr [ i ] ; } Coef = 2 ; for ( r2 = 0 ; r2 < 3 ; r2 ++ ) { if ( Coef == 2 ) { Coef = 4 ; } else { Coef = 2 ; } for ( i = 0 ; i < 16 ; i ++ ) { a_p [ i ] = ( ( real_T ) r2 + 1.0 ) * a [ i ] * pcdjaqurn1 ; } mw3hm0er3e ( a_p , tmp_p ) ; for ( i = 0 ; i < 16 ; i ++ ) { Ai [ i ] += ( real_T ) Coef * tmp_p [ i ] ; } } pcdjaqurn1 /= 3.0 ; for ( i = 0 ; i < 4 ; i ++ ) { U_idx_0 = Ai [ i + 4 ] ; Y_idx_0 = Ai [ i ] ; Y_idx_1 = Ai [ i + 8 ] ; U_idx_1 = Ai [ i + 12 ] ; for ( r2 = 0 ; r2 < 2 ; r2 ++ ) { nah5npyaz2 [ i + ( r2 << 2 ) ] = ( ( b [ ( r2 << 2 ) + 1 ] * ( U_idx_0 * pcdjaqurn1 ) + pcdjaqurn1 * Y_idx_0 * b [ r2 << 2 ] ) + Y_idx_1 * pcdjaqurn1 * 0.0 ) + b [ ( r2 << 2 ) + 3 ] * ( U_idx_1 * pcdjaqurn1 ) ; } } memcpy ( & b [ 0 ] , & nah5npyaz2 [ 0 ] , sizeof ( real_T ) << 3U ) ; } else { memcpy ( & furzsrerqr [ 0 ] , & a [ 0 ] , sizeof ( real_T ) << 4U ) ; } rtDW . oikgzdquty = jbznyvk4nl ; memset ( & Bu [ 0 ] , 0 , 55U * sizeof ( real_T ) ) ; memset ( & Bv [ 0 ] , 0 , 110U * sizeof ( real_T ) ) ; memset ( & Dv [ 0 ] , 0 , 44U * sizeof ( real_T ) ) ; for ( i = 0 ; i < 44 ; i ++ ) { Dvm [ i ] = 0 ; } memset ( & Cm [ 0 ] , 0 , 110U * sizeof ( real_T ) ) ; memcpy ( & b_A [ 0 ] , & c [ 0 ] , 25U * sizeof ( real_T ) ) ; memcpy ( & b_B [ 0 ] , & d [ 0 ] , 30U * sizeof ( real_T ) ) ; for ( i = 0 ; i < 10 ; i ++ ) { b_C [ i ] = e [ i ] ; } for ( i = 0 ; i < 12 ; i ++ ) { b_D [ i ] = f [ i ] ; } for ( i = 0 ; i < 8 ; i ++ ) { b [ i ] *= g [ i ] ; } for ( i = 0 ; i < 4 ; i ++ ) { b_C [ i << 1 ] = ( real_T ) tmp_g [ i << 1 ] / h [ i << 1 ] ; b_C [ ( i << 1 ) + 1 ] = ( real_T ) tmp_g [ ( i << 1 ) + 1 ] / h [ ( i << 1 ) + 1 ] ; b_A [ 5 * i ] = furzsrerqr [ i << 2 ] ; b_A [ 5 * i + 1 ] = furzsrerqr [ ( i << 2 ) + 1 ] ; b_A [ 5 * i + 2 ] = furzsrerqr [ ( i << 2 ) + 2 ] ; b_A [ 5 * i + 3 ] = furzsrerqr [ ( i << 2 ) + 3 ] ; b_B [ i ] = b [ i ] ; b_B [ i + 5 ] = b [ i + 4 ] ; } b_D [ 2 ] = 0 ; b_D [ 3 ] = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { Bu [ i ] = b_B [ i ] ; } memcpy ( & Bv [ 0 ] , & b_B [ 5 ] , 10U * sizeof ( real_T ) ) ; Dvm [ 0 ] = 0 ; Dvm [ 1 ] = 0 ; Dvm [ 2 ] = b_D [ 4 ] ; Dvm [ 3 ] = b_D [ 5 ] ; UnknownIn [ 0 ] = 1.0 ; UnknownIn [ 1 ] = 2.0 ; UnknownIn [ 2 ] = 4.0 ; UnknownIn [ 3 ] = 5.0 ; UnknownIn [ 4 ] = 6.0 ; for ( i = 0 ; i < 5 ; i ++ ) { Cm [ i << 1 ] = b_C [ i << 1 ] ; Cm [ ( i << 1 ) + 1 ] = b_C [ ( i << 1 ) + 1 ] ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { b_tmp [ r2 + 7 * i ] = b_B [ ( ( int32_T ) UnknownIn [ i ] - 1 ) * 5 + r2 ] ; } Coef = ( int32_T ) UnknownIn [ i ] ; b_tmp [ 7 * i + 5 ] = b_D [ ( Coef - 1 ) << 1 ] ; b_tmp [ 7 * i + 6 ] = b_D [ ( ( Coef - 1 ) << 1 ) + 1 ] ; } for ( i = 0 ; i < 7 ; i ++ ) { for ( r2 = 0 ; r2 < 7 ; r2 ++ ) { U_idx_0 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { U_idx_0 += b_tmp [ 7 * Coef + i ] * b_tmp [ 7 * Coef + r2 ] ; } CovMat [ i + 7 * r2 ] = U_idx_0 ; } } Dv [ 0 ] = 0.0 ; Dv [ 1 ] = 0.0 ; Dv [ 2 ] = b_D [ 4 ] ; Dv [ 3 ] = b_D [ 5 ] ; for ( i = 0 ; i < 5 ; i ++ ) { UnknownIn [ i ] = 0.0 ; } U_idx_0 = rtP . UConstant_Value [ 0 ] ; Y_idx_0 = rtP . YConstant_Value [ 0 ] / 0.5 ; U_idx_1 = rtP . UConstant_Value [ 1 ] / 0.01 ; Y_idx_1 = rtP . YConstant_Value [ 1 ] / 0.1 ; baq5ffy01v [ 0 ] = ( hbbpvc4znc - rtP . UConstant_Value [ 0 ] ) + 0.5 ; UnknownIn [ 0 ] = rtP . XConstant_Value [ 0 ] ; Bv [ 5 ] = rtP . DXConstant_Value [ 0 ] ; baq5ffy01v [ 1 ] = ( hbbpvc4znc - rtP . UConstant_Value [ 0 ] ) + 0.5 ; UnknownIn [ 1 ] = rtP . XConstant_Value [ 1 ] ; Bv [ 6 ] = rtP . DXConstant_Value [ 1 ] ; baq5ffy01v [ 2 ] = 0.5 - ( hbbpvc4znc - rtP . UConstant_Value [ 0 ] ) ; UnknownIn [ 2 ] = rtP . XConstant_Value [ 2 ] ; Bv [ 7 ] = rtP . DXConstant_Value [ 2 ] ; baq5ffy01v [ 3 ] = 0.5 - ( hbbpvc4znc - rtP . UConstant_Value [ 0 ] ) ; UnknownIn [ 3 ] = rtP . XConstant_Value [ 3 ] ; Bv [ 8 ] = rtP . DXConstant_Value [ 3 ] ; memset ( & vseq [ 0 ] , 0 , 22U * sizeof ( real_T ) ) ; for ( r2 = 0 ; r2 < 11 ; r2 ++ ) { vseq [ ( r2 << 1 ) + 1 ] = 1.0 ; } Referenceconstant_Value = rtP . Referenceconstant_Value [ 0 ] ; pcdjaqurn1 = rtP . Referenceconstant_Value [ 1 ] ; for ( Coef = 0 ; Coef < 10 ; Coef ++ ) { rseq [ Coef << 1 ] = Referenceconstant_Value * 2.0 - Y_idx_0 ; rseq [ ( Coef << 1 ) + 1 ] = pcdjaqurn1 * 10.0 - Y_idx_1 ; } for ( Coef = 0 ; Coef < 11 ; Coef ++ ) { vseq [ Coef << 1 ] = bzrcm5agek * cyalvcgwla [ Coef ] - U_idx_1 ; } U_idx_1 = vseq [ 0 ] ; Referenceconstant_Value = vseq [ 1 ] ; c_B [ 0 ] = 0 ; c_B [ 1 ] = 0 ; c_B [ 2 ] = 0 ; c_B [ 3 ] = 0 ; for ( Coef = 0 ; Coef < 2 ; Coef ++ ) { c_B [ Coef + ( Coef << 1 ) ] = 1 ; for ( i = 0 ; i < 5 ; i ++ ) { pcdjaqurn1 = 0.0 ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 += Cm [ ( r2 << 1 ) + Coef ] * rtDW . kwh42zszzd [ 5 * i + r2 ] ; } L [ Coef + ( i << 1 ) ] = pcdjaqurn1 ; } for ( i = 0 ; i < 2 ; i ++ ) { pcdjaqurn1 = 0.0 ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 += L [ ( r2 << 1 ) + Coef ] * Cm [ ( r2 << 1 ) + i ] ; } c_a [ Coef + ( i << 1 ) ] = CovMat [ ( ( i + 5 ) * 7 + Coef ) + 5 ] + pcdjaqurn1 ; } } if ( muDoubleScalarAbs ( c_a [ 1 ] ) > muDoubleScalarAbs ( c_a [ 0 ] ) ) { Coef = 1 ; r2 = 0 ; } else { Coef = 0 ; r2 = 1 ; } pcdjaqurn1 = c_a [ r2 ] / c_a [ Coef ] ; a22 = c_a [ r2 + 2 ] - c_a [ Coef + 2 ] * pcdjaqurn1 ; Kinv [ Coef << 1 ] = ( real_T ) c_B [ 0 ] / c_a [ Coef ] ; Kinv [ r2 << 1 ] = ( ( real_T ) c_B [ 2 ] - Kinv [ Coef << 1 ] * c_a [ Coef + 2 ] ) / a22 ; Kinv [ Coef << 1 ] -= Kinv [ r2 << 1 ] * pcdjaqurn1 ; Kinv [ ( Coef << 1 ) + 1 ] = ( real_T ) c_B [ 1 ] / c_a [ Coef ] ; Kinv [ ( r2 << 1 ) + 1 ] = ( ( real_T ) c_B [ 3 ] - Kinv [ ( Coef << 1 ) + 1 ] * c_a [ Coef + 2 ] ) / a22 ; Kinv [ ( Coef << 1 ) + 1 ] -= Kinv [ ( r2 << 1 ) + 1 ] * pcdjaqurn1 ; for ( i = 0 ; i < 5 ; i ++ ) { for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { pcdjaqurn1 += b_A [ 5 * Coef + i ] * rtDW . kwh42zszzd [ 5 * r2 + Coef ] ; } b_A_p [ i + 5 * r2 ] = pcdjaqurn1 ; } for ( r2 = 0 ; r2 < 2 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { pcdjaqurn1 += b_A_p [ 5 * Coef + i ] * Cm [ ( Coef << 1 ) + r2 ] ; } b_A_e [ i + 5 * r2 ] = CovMat [ ( r2 + 5 ) * 7 + i ] + pcdjaqurn1 ; } pcdjaqurn1 = b_A_e [ i + 5 ] ; a22 = b_A_e [ i ] ; L [ i ] = pcdjaqurn1 * Kinv [ 1 ] + a22 * Kinv [ 0 ] ; L [ i + 5 ] = pcdjaqurn1 * Kinv [ 3 ] + a22 * Kinv [ 2 ] ; cqnehczjtf [ i ] = ( cqnehczjtf [ i ] - UnknownIn [ i ] ) + Bu [ i ] * 0.0 ; } tmp_e [ 0 ] = rtB . k1mx4005qx . mccd0iruvd * 2.0 - Y_idx_0 ; tmp_e [ 1 ] = rtB . gnys0rptin . mccd0iruvd * 10.0 - Y_idx_1 ; for ( i = 0 ; i < 2 ; i ++ ) { pcdjaqurn1 = 0.0 ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 += Cm [ ( r2 << 1 ) + i ] * cqnehczjtf [ r2 ] ; } y_innov [ i ] = tmp_e [ i ] - ( ( ( real_T ) Dvm [ i + 2 ] * Referenceconstant_Value + ( real_T ) Dvm [ i ] * U_idx_1 ) + pcdjaqurn1 ) ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( r2 = 0 ; r2 < 2 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { pcdjaqurn1 += rtDW . kwh42zszzd [ 5 * Coef + i ] * Cm [ ( Coef << 1 ) + r2 ] ; } b_A_e [ i + 5 * r2 ] = pcdjaqurn1 ; } pcdjaqurn1 = b_A_e [ i + 5 ] ; Y_idx_0 = b_A_e [ i ] ; lp5v4nuilo [ i ] = ( ( pcdjaqurn1 * Kinv [ 1 ] + Y_idx_0 * Kinv [ 0 ] ) * y_innov [ 0 ] + ( pcdjaqurn1 * Kinv [ 3 ] + Y_idx_0 * Kinv [ 2 ] ) * y_innov [ 1 ] ) + cqnehczjtf [ i ] ; } memset ( & tmp_i [ 0 ] , 0 , 20U * sizeof ( real_T ) ) ; memset ( & tmp_m [ 0 ] , 0 , 88U * sizeof ( real_T ) ) ; for ( i = 0 ; i < 10 ; i ++ ) { b_A_e [ i ] = 0.0 - U_idx_0 ; } kaaxjzuhhx ( rseq , vseq , rtB . bk3nxv3tlr . onhvape52u , rtB . cc1fon30yl . onhvape52u , ( ( rtP . Enableoptimizationconstant_Value > 0.0 ) || ( rtP . Enableoptimizationconstant_Value < 0.0 ) ) , lp5v4nuilo , jx5vcee1jt - rtP . UConstant_Value [ 0 ] , rtDW . pswc1mgssa , baq5ffy01v , tmp_i , t , tmp_m , b_A_e , rtP . UConstant_Value [ 0 ] , 0 , x , b_A , Bu , Bv , b_C , Dv , & pcdjaqurn1 , cyalvcgwla , & a22 , rtB . etstptzcgp ) ; rtB . o0gndlrdqg = pcdjaqurn1 ; jx5vcee1jt = pcdjaqurn1 - rtP . UConstant_Value [ 0 ] ; for ( i = 0 ; i < 5 ; i ++ ) { for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; a22 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { U_idx_0 = b_A [ 5 * Coef + i ] ; Y_idx_0 = rtDW . kwh42zszzd [ 5 * r2 + Coef ] ; pcdjaqurn1 += U_idx_0 * Y_idx_0 ; a22 += U_idx_0 * Y_idx_0 ; } b_A_i [ i + 5 * r2 ] = a22 ; b_A_p [ i + 5 * r2 ] = pcdjaqurn1 ; } for ( r2 = 0 ; r2 < 2 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { pcdjaqurn1 += b_A_i [ 5 * Coef + i ] * Cm [ ( Coef << 1 ) + r2 ] ; } b_A_e [ i + 5 * r2 ] = CovMat [ ( r2 + 5 ) * 7 + i ] + pcdjaqurn1 ; } for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { pcdjaqurn1 = 0.0 ; for ( Coef = 0 ; Coef < 5 ; Coef ++ ) { pcdjaqurn1 += b_A_p [ 5 * Coef + i ] * b_A [ 5 * Coef + r2 ] ; } b_A_m [ i + 5 * r2 ] = pcdjaqurn1 ; } } for ( i = 0 ; i < 5 ; i ++ ) { pcdjaqurn1 = b_A_e [ i + 5 ] ; a22 = b_A_e [ i ] ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { b_A_p [ i + 5 * r2 ] = L [ r2 + 5 ] * pcdjaqurn1 + a22 * L [ r2 ] ; } } for ( i = 0 ; i < 5 ; i ++ ) { for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { b_A_i [ r2 + 5 * i ] = ( b_A_m [ 5 * i + r2 ] - b_A_p [ 5 * i + r2 ] ) + CovMat [ 7 * i + r2 ] ; } } for ( i = 0 ; i < 5 ; i ++ ) { pcdjaqurn1 = 0.0 ; for ( r2 = 0 ; r2 < 5 ; r2 ++ ) { rtB . ns4zakixk4 [ r2 + 5 * i ] = ( b_A_i [ 5 * i + r2 ] + b_A_i [ 5 * r2 + i ] ) * 0.5 ; pcdjaqurn1 += b_A [ 5 * r2 + i ] * cqnehczjtf [ r2 ] ; } rtB . kjjzvf0odm [ i ] = ( ( ( Bv [ i + 5 ] * Referenceconstant_Value + Bv [ i ] * U_idx_1 ) + ( Bu [ i ] * jx5vcee1jt + pcdjaqurn1 ) ) + ( L [ i + 5 ] * y_innov [ 1 ] + L [ i ] * y_innov [ 0 ] ) ) + UnknownIn [ i ] ; } jx5vcee1jt = rtP . u_scale_Gain * rtB . o0gndlrdqg ; { if ( rtDW . kz0usvbqfo . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . kz0usvbqfo . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & jx5vcee1jt + 0 ) ; } } { if ( rtDW . h35e1w25qj . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . h35e1w25qj . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & rtB . jl0aukavwi + 0 ) ; } } { if ( rtDW . a5r4vbzi4b . AQHandles && ssGetLogOutput ( rtS ) ) { sdiWriteSignal ( rtDW . a5r4vbzi4b . AQHandles , ssGetTaskTime ( rtS , 1 ) , ( char * ) & rtB . itiywpghyu + 0 ) ; } } a22 = 1.0 / rtP . Vx * rtP . Constant_Value ; rtB . k0suforjme = 2.0 * rtP . Cf / rtP . m * jx5vcee1jt ; rtB . o13qcxbdip = - ( 2.0 * rtP . Cf + 2.0 * rtP . Cr ) / rtP . m * a22 ; rtB . ncih2tph21 = - ( 2.0 * rtP . Cf * rtP . lf - 2.0 * rtP . Cr * rtP . lr ) / rtP . Iz * a22 ; rtB . pend3mkk21 = rtP . Gain4_Gain_nzox2md245 * a22 ; rtB . bfv1nrsihf = 2.0 * rtP . Cf * rtP . lf / rtP . Iz * jx5vcee1jt ; rtB . jufm00blrf = - ( 2.0 * rtP . Cf * rtP . lf - 2.0 * rtP . Cr * rtP . lr ) / rtP . m * a22 - rtP . Vx ; } jx5vcee1jt = rtX . ntspwlarvq ; pcdjaqurn1 = rtX . jbfykaxbhu ; rtB . glp22kvlec = ( rtX . ntspwlarvq * rtB . o13qcxbdip + rtB . jufm00blrf * rtX . jbfykaxbhu ) + rtB . k0suforjme ; rtB . dvyu1sscyo = ( rtX . ntspwlarvq * rtB . ncih2tph21 + rtB . pend3mkk21 * rtX . jbfykaxbhu ) + rtB . bfv1nrsihf ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtP . Assertion_Enabled && ( ! ( rtP . Longitudinalvelocitymustbepositive_min < rtP . Vx ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "Simulink:blocks:AssertionAssert" , 2 , 5 , "LKA_T_staliro/Subsystem/Lane Keeping Assist System/Longitudinal velocity must be positive/Assertion" , 2 , ssGetT ( rtS ) ) ; rt_ssSet_slErrMsg ( S , diag ) ; ssSetStopRequested ( rtS , ( int ) ssGetT ( rtS ) ) ; } kj444jmrfp ( rtP . Externalcontrolsignalconstant_Value , & rtB . cik2vkh3a4 , & rtDW . cik2vkh3a4 ) ; hpytpcdps5 ( & rtDW . gqjzh0f3es ) ; rtDW . h4zkufiov3 = jbznyvk4nl ; hpytpcdps5 ( & rtDW . cvyjidmo4f ) ; rtB . cvvfihfwkh = rtP . Vx * rtB . p42cer33ct ; } rtB . d4mpdlgsh1 = pcdjaqurn1 - rtB . cvvfihfwkh ; rtB . bjzx13hfvh = rtP . Vx * rtB . itiywpghyu + jx5vcee1jt ; UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID2 ( int_T tid ) { rtB . dxboshnqcx [ 0 ] = rtP . ywt_zero_Value [ 0 ] ; rtB . dxboshnqcx [ 1 ] = rtP . ywt_zero_Value [ 1 ] ; rtB . cffmjtonjb = rtP . uwt_zero_Value ; rtB . opyhkzbx15 = rtP . duwt_zero_Value ; UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { int32_T i ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { for ( i = 0 ; i < 5 ; i ++ ) { rtDW . mwdhrz5xb1 [ i ] = rtB . kjjzvf0odm [ i ] ; } rtDW . j45svihtjo = rtB . o0gndlrdqg ; rtDW . oen24533b2 = rtB . ppw1rz40hr ; memcpy ( & rtDW . kwh42zszzd [ 0 ] , & rtB . ns4zakixk4 [ 0 ] , 25U * sizeof ( real_T ) ) ; rtDW . pswc1mgssa [ 0 ] = rtB . etstptzcgp [ 0 ] ; rtDW . pswc1mgssa [ 1 ] = rtB . etstptzcgp [ 1 ] ; rtDW . pswc1mgssa [ 2 ] = rtB . etstptzcgp [ 2 ] ; rtDW . pswc1mgssa [ 3 ] = rtB . etstptzcgp [ 3 ] ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID2 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { XDot * _rtXdot ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> fivs40guhu = rtB . bjzx13hfvh ; _rtXdot -> obmuwhiu30 = rtB . d4mpdlgsh1 ; _rtXdot -> ntspwlarvq = rtB . glp22kvlec ; _rtXdot -> jbfykaxbhu = rtB . dvyu1sscyo ; } void MdlProjection ( void ) { } void MdlTerminate ( void ) { { if ( rtDW . kz0usvbqfo . AQHandles ) { sdiTerminateStreaming ( & rtDW . kz0usvbqfo . AQHandles ) ; } } { if ( rtDW . h35e1w25qj . AQHandles ) { sdiTerminateStreaming ( & rtDW . h35e1w25qj . AQHandles ) ; } } { if ( rtDW . a5r4vbzi4b . AQHandles ) { sdiTerminateStreaming ( & rtDW . a5r4vbzi4b . AQHandles ) ; } } } static void mr_LKA_T_staliro_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_LKA_T_staliro_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_LKA_T_staliro_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_LKA_T_staliro_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_LKA_T_staliro_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_LKA_T_staliro_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_LKA_T_staliro_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_LKA_T_staliro_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_LKA_T_staliro_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_LKA_T_staliro_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_LKA_T_staliro_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_LKA_T_staliro_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_LKA_T_staliro_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_LKA_T_staliro_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_LKA_T_staliro_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_LKA_T_staliro_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_LKA_T_staliro_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 49 ] = { "rtDW.j45svihtjo" , "rtDW.mwdhrz5xb1" , "rtDW.oen24533b2" , "rtDW.kwh42zszzd" , "rtDW.h4zkufiov3" , "rtDW.fwdhnrc1pz" , "rtDW.e51nkuwvdf" , "rtDW.j0i5djvvgw" , "rtDW.oikgzdquty" , "rtDW.evq0kveuwk" , "rtDW.pswc1mgssa" , "rtDW.b5dfi4px0f" , "rtDW.eav1tlopa2" , "rtDW.hgfwy0uny1" , "rtDW.axawio3aws" , "rtDW.byo3k50uq4" , "rtDW.bjss44da1o" , "rtDW.euyeijkvwj.ad0pg2zl2x" , "rtDW.euyeijkvwj.am1q23zvbk" , "rtDW.kug2oixzkm.ad0pg2zl2x" , "rtDW.kug2oixzkm.am1q23zvbk" , "rtDW.lzaj2qo24h.ad0pg2zl2x" , "rtDW.lzaj2qo24h.am1q23zvbk" , "rtDW.e5mwwrj2xv.ad0pg2zl2x" , "rtDW.e5mwwrj2xv.am1q23zvbk" , "rtDW.elsnrsfkpu.ad0pg2zl2x" , "rtDW.elsnrsfkpu.am1q23zvbk" , "rtDW.gnn330lieg.ad0pg2zl2x" , "rtDW.gnn330lieg.am1q23zvbk" , "rtDW.be3jllceim.ad0pg2zl2x" , "rtDW.be3jllceim.am1q23zvbk" , "rtDW.gnys0rptin.ov2ak15hts" , "rtDW.gnys0rptin.mz5ndlrakh" , "rtDW.k1mx4005qx.ov2ak15hts" , "rtDW.k1mx4005qx.mz5ndlrakh" , "rtDW.gccus3jafp.ad0pg2zl2x" , "rtDW.gccus3jafp.am1q23zvbk" , "rtDW.njn5yczmu3.ad0pg2zl2x" , "rtDW.njn5yczmu3.am1q23zvbk" , "rtDW.cvyjidmo4f.akqsbdynir" , "rtDW.cvyjidmo4f.pckcm0tazc" , "rtDW.gqjzh0f3es.akqsbdynir" , "rtDW.gqjzh0f3es.pckcm0tazc" , "rtDW.cik2vkh3a4.ad0pg2zl2x" , "rtDW.cik2vkh3a4.am1q23zvbk" , "rtDW.bk3nxv3tlr.ad0pg2zl2x" , "rtDW.bk3nxv3tlr.am1q23zvbk" , "rtDW.cc1fon30yl.ad0pg2zl2x" , "rtDW.cc1fon30yl.am1q23zvbk" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 49 , rtdwDataFieldNames ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . j45svihtjo ) , sizeof ( rtDW . j45svihtjo ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . mwdhrz5xb1 ) , sizeof ( rtDW . mwdhrz5xb1 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . oen24533b2 ) , sizeof ( rtDW . oen24533b2 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . kwh42zszzd ) , sizeof ( rtDW . kwh42zszzd ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . h4zkufiov3 ) , sizeof ( rtDW . h4zkufiov3 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . fwdhnrc1pz ) , sizeof ( rtDW . fwdhnrc1pz ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . e51nkuwvdf ) , sizeof ( rtDW . e51nkuwvdf ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . j0i5djvvgw ) , sizeof ( rtDW . j0i5djvvgw ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . oikgzdquty ) , sizeof ( rtDW . oikgzdquty ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . evq0kveuwk ) , sizeof ( rtDW . evq0kveuwk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . pswc1mgssa ) , sizeof ( rtDW . pswc1mgssa ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . b5dfi4px0f ) , sizeof ( rtDW . b5dfi4px0f ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . eav1tlopa2 ) , sizeof ( rtDW . eav1tlopa2 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . hgfwy0uny1 ) , sizeof ( rtDW . hgfwy0uny1 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . axawio3aws ) , sizeof ( rtDW . axawio3aws ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . byo3k50uq4 ) , sizeof ( rtDW . byo3k50uq4 ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . bjss44da1o ) , sizeof ( rtDW . bjss44da1o ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . euyeijkvwj . ad0pg2zl2x ) , sizeof ( rtDW . euyeijkvwj . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( rtDW . euyeijkvwj . am1q23zvbk ) , sizeof ( rtDW . euyeijkvwj . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( rtDW . kug2oixzkm . ad0pg2zl2x ) , sizeof ( rtDW . kug2oixzkm . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( rtDW . kug2oixzkm . am1q23zvbk ) , sizeof ( rtDW . kug2oixzkm . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( rtDW . lzaj2qo24h . ad0pg2zl2x ) , sizeof ( rtDW . lzaj2qo24h . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( rtDW . lzaj2qo24h . am1q23zvbk ) , sizeof ( rtDW . lzaj2qo24h . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( rtDW . e5mwwrj2xv . ad0pg2zl2x ) , sizeof ( rtDW . e5mwwrj2xv . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( rtDW . e5mwwrj2xv . am1q23zvbk ) , sizeof ( rtDW . e5mwwrj2xv . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( rtDW . elsnrsfkpu . ad0pg2zl2x ) , sizeof ( rtDW . elsnrsfkpu . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( rtDW . elsnrsfkpu . am1q23zvbk ) , sizeof ( rtDW . elsnrsfkpu . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( rtDW . gnn330lieg . ad0pg2zl2x ) , sizeof ( rtDW . gnn330lieg . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( rtDW . gnn330lieg . am1q23zvbk ) , sizeof ( rtDW . gnn330lieg . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( rtDW . be3jllceim . ad0pg2zl2x ) , sizeof ( rtDW . be3jllceim . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 30 , ( const void * ) & ( rtDW . be3jllceim . am1q23zvbk ) , sizeof ( rtDW . be3jllceim . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 31 , ( const void * ) & ( rtDW . gnys0rptin . ov2ak15hts ) , sizeof ( rtDW . gnys0rptin . ov2ak15hts ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 32 , ( const void * ) & ( rtDW . gnys0rptin . mz5ndlrakh ) , sizeof ( rtDW . gnys0rptin . mz5ndlrakh ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 33 , ( const void * ) & ( rtDW . k1mx4005qx . ov2ak15hts ) , sizeof ( rtDW . k1mx4005qx . ov2ak15hts ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 34 , ( const void * ) & ( rtDW . k1mx4005qx . mz5ndlrakh ) , sizeof ( rtDW . k1mx4005qx . mz5ndlrakh ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 35 , ( const void * ) & ( rtDW . gccus3jafp . ad0pg2zl2x ) , sizeof ( rtDW . gccus3jafp . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 36 , ( const void * ) & ( rtDW . gccus3jafp . am1q23zvbk ) , sizeof ( rtDW . gccus3jafp . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 37 , ( const void * ) & ( rtDW . njn5yczmu3 . ad0pg2zl2x ) , sizeof ( rtDW . njn5yczmu3 . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 38 , ( const void * ) & ( rtDW . njn5yczmu3 . am1q23zvbk ) , sizeof ( rtDW . njn5yczmu3 . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 39 , ( const void * ) & ( rtDW . cvyjidmo4f . akqsbdynir ) , sizeof ( rtDW . cvyjidmo4f . akqsbdynir ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 40 , ( const void * ) & ( rtDW . cvyjidmo4f . pckcm0tazc ) , sizeof ( rtDW . cvyjidmo4f . pckcm0tazc ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 41 , ( const void * ) & ( rtDW . gqjzh0f3es . akqsbdynir ) , sizeof ( rtDW . gqjzh0f3es . akqsbdynir ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 42 , ( const void * ) & ( rtDW . gqjzh0f3es . pckcm0tazc ) , sizeof ( rtDW . gqjzh0f3es . pckcm0tazc ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 43 , ( const void * ) & ( rtDW . cik2vkh3a4 . ad0pg2zl2x ) , sizeof ( rtDW . cik2vkh3a4 . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 44 , ( const void * ) & ( rtDW . cik2vkh3a4 . am1q23zvbk ) , sizeof ( rtDW . cik2vkh3a4 . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 45 , ( const void * ) & ( rtDW . bk3nxv3tlr . ad0pg2zl2x ) , sizeof ( rtDW . bk3nxv3tlr . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 46 , ( const void * ) & ( rtDW . bk3nxv3tlr . am1q23zvbk ) , sizeof ( rtDW . bk3nxv3tlr . am1q23zvbk ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 47 , ( const void * ) & ( rtDW . cc1fon30yl . ad0pg2zl2x ) , sizeof ( rtDW . cc1fon30yl . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_cacheDataAsMxArray ( rtdwData , 0 , 48 , ( const void * ) & ( rtDW . cc1fon30yl . am1q23zvbk ) , sizeof ( rtDW . cc1fon30yl . am1q23zvbk ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_LKA_T_staliro_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . j45svihtjo ) , rtdwData , 0 , 0 , sizeof ( rtDW . j45svihtjo ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . mwdhrz5xb1 ) , rtdwData , 0 , 1 , sizeof ( rtDW . mwdhrz5xb1 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . oen24533b2 ) , rtdwData , 0 , 2 , sizeof ( rtDW . oen24533b2 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . kwh42zszzd ) , rtdwData , 0 , 3 , sizeof ( rtDW . kwh42zszzd ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . h4zkufiov3 ) , rtdwData , 0 , 4 , sizeof ( rtDW . h4zkufiov3 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . fwdhnrc1pz ) , rtdwData , 0 , 5 , sizeof ( rtDW . fwdhnrc1pz ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . e51nkuwvdf ) , rtdwData , 0 , 6 , sizeof ( rtDW . e51nkuwvdf ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . j0i5djvvgw ) , rtdwData , 0 , 7 , sizeof ( rtDW . j0i5djvvgw ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . oikgzdquty ) , rtdwData , 0 , 8 , sizeof ( rtDW . oikgzdquty ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . evq0kveuwk ) , rtdwData , 0 , 9 , sizeof ( rtDW . evq0kveuwk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . pswc1mgssa ) , rtdwData , 0 , 10 , sizeof ( rtDW . pswc1mgssa ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . b5dfi4px0f ) , rtdwData , 0 , 11 , sizeof ( rtDW . b5dfi4px0f ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . eav1tlopa2 ) , rtdwData , 0 , 12 , sizeof ( rtDW . eav1tlopa2 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . hgfwy0uny1 ) , rtdwData , 0 , 13 , sizeof ( rtDW . hgfwy0uny1 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . axawio3aws ) , rtdwData , 0 , 14 , sizeof ( rtDW . axawio3aws ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . byo3k50uq4 ) , rtdwData , 0 , 15 , sizeof ( rtDW . byo3k50uq4 ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . bjss44da1o ) , rtdwData , 0 , 16 , sizeof ( rtDW . bjss44da1o ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . euyeijkvwj . ad0pg2zl2x ) , rtdwData , 0 , 17 , sizeof ( rtDW . euyeijkvwj . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . euyeijkvwj . am1q23zvbk ) , rtdwData , 0 , 18 , sizeof ( rtDW . euyeijkvwj . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . kug2oixzkm . ad0pg2zl2x ) , rtdwData , 0 , 19 , sizeof ( rtDW . kug2oixzkm . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . kug2oixzkm . am1q23zvbk ) , rtdwData , 0 , 20 , sizeof ( rtDW . kug2oixzkm . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . lzaj2qo24h . ad0pg2zl2x ) , rtdwData , 0 , 21 , sizeof ( rtDW . lzaj2qo24h . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . lzaj2qo24h . am1q23zvbk ) , rtdwData , 0 , 22 , sizeof ( rtDW . lzaj2qo24h . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . e5mwwrj2xv . ad0pg2zl2x ) , rtdwData , 0 , 23 , sizeof ( rtDW . e5mwwrj2xv . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . e5mwwrj2xv . am1q23zvbk ) , rtdwData , 0 , 24 , sizeof ( rtDW . e5mwwrj2xv . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . elsnrsfkpu . ad0pg2zl2x ) , rtdwData , 0 , 25 , sizeof ( rtDW . elsnrsfkpu . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . elsnrsfkpu . am1q23zvbk ) , rtdwData , 0 , 26 , sizeof ( rtDW . elsnrsfkpu . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gnn330lieg . ad0pg2zl2x ) , rtdwData , 0 , 27 , sizeof ( rtDW . gnn330lieg . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gnn330lieg . am1q23zvbk ) , rtdwData , 0 , 28 , sizeof ( rtDW . gnn330lieg . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . be3jllceim . ad0pg2zl2x ) , rtdwData , 0 , 29 , sizeof ( rtDW . be3jllceim . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . be3jllceim . am1q23zvbk ) , rtdwData , 0 , 30 , sizeof ( rtDW . be3jllceim . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gnys0rptin . ov2ak15hts ) , rtdwData , 0 , 31 , sizeof ( rtDW . gnys0rptin . ov2ak15hts ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gnys0rptin . mz5ndlrakh ) , rtdwData , 0 , 32 , sizeof ( rtDW . gnys0rptin . mz5ndlrakh ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . k1mx4005qx . ov2ak15hts ) , rtdwData , 0 , 33 , sizeof ( rtDW . k1mx4005qx . ov2ak15hts ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . k1mx4005qx . mz5ndlrakh ) , rtdwData , 0 , 34 , sizeof ( rtDW . k1mx4005qx . mz5ndlrakh ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gccus3jafp . ad0pg2zl2x ) , rtdwData , 0 , 35 , sizeof ( rtDW . gccus3jafp . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gccus3jafp . am1q23zvbk ) , rtdwData , 0 , 36 , sizeof ( rtDW . gccus3jafp . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . njn5yczmu3 . ad0pg2zl2x ) , rtdwData , 0 , 37 , sizeof ( rtDW . njn5yczmu3 . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . njn5yczmu3 . am1q23zvbk ) , rtdwData , 0 , 38 , sizeof ( rtDW . njn5yczmu3 . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cvyjidmo4f . akqsbdynir ) , rtdwData , 0 , 39 , sizeof ( rtDW . cvyjidmo4f . akqsbdynir ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cvyjidmo4f . pckcm0tazc ) , rtdwData , 0 , 40 , sizeof ( rtDW . cvyjidmo4f . pckcm0tazc ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gqjzh0f3es . akqsbdynir ) , rtdwData , 0 , 41 , sizeof ( rtDW . gqjzh0f3es . akqsbdynir ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . gqjzh0f3es . pckcm0tazc ) , rtdwData , 0 , 42 , sizeof ( rtDW . gqjzh0f3es . pckcm0tazc ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cik2vkh3a4 . ad0pg2zl2x ) , rtdwData , 0 , 43 , sizeof ( rtDW . cik2vkh3a4 . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cik2vkh3a4 . am1q23zvbk ) , rtdwData , 0 , 44 , sizeof ( rtDW . cik2vkh3a4 . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . bk3nxv3tlr . ad0pg2zl2x ) , rtdwData , 0 , 45 , sizeof ( rtDW . bk3nxv3tlr . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . bk3nxv3tlr . am1q23zvbk ) , rtdwData , 0 , 46 , sizeof ( rtDW . bk3nxv3tlr . am1q23zvbk ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cc1fon30yl . ad0pg2zl2x ) , rtdwData , 0 , 47 , sizeof ( rtDW . cc1fon30yl . ad0pg2zl2x ) ) ; mr_LKA_T_staliro_restoreDataFromMxArray ( ( void * ) & ( rtDW . cc1fon30yl . am1q23zvbk ) , rtdwData , 0 , 48 , sizeof ( rtDW . cc1fon30yl . am1q23zvbk ) ) ; } } mxArray * mr_LKA_T_staliro_GetSimStateDisallowedBlocks ( ) { return ( NULL ) ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 4 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 1 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 2 ) ; ssSetNumBlocks ( rtS , 133 ) ; ssSetNumBlockIO ( rtS , 52 ) ; ssSetNumBlockParams ( rtS , 120 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.1 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 2717182362U ) ; ssSetChecksumVal ( rtS , 1 , 1965175627U ) ; ssSetChecksumVal ( rtS , 2 , 3343308624U ) ; ssSetChecksumVal ( rtS , 3 , 1323682619U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { ssSetY ( rtS , & rtY ) ; rtY . ggwcqiyygf = 0.0 ; ssSetWorkSizeInBytes ( rtS , sizeof ( rtY ) , "YOut" ) ; } { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 29 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } LKA_T_staliro_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "LKA_T_staliro" ) ; ssSetPath ( rtS , "LKA_T_staliro" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 15.0 ) ; ssSetStepSize ( rtS , 0.1 ) ; ssSetFixedStepSize ( rtS , 0.1 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 1 , 1 , 1 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "LKA_T_staliro/Subsystem/Sensor Dynamics/Integrator" , "LKA_T_staliro/Subsystem/Sensor Dynamics/Integrator2" , "LKA_T_staliro/Subsystem/Ego Vehicle Dynamics/Vy" , "LKA_T_staliro/Subsystem/Ego Vehicle Dynamics/Yaw_rate\n" , "LKA_T_staliro/Subsystem/Lane Keeping Assist System/Adaptive MPC for LKA/Adaptive MPC Controller/MPC/last_mv" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "" , "" , "" , "" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 2 , 3 , 0 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 5 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 5 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . fivs40guhu ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtX . obmuwhiu30 ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtX . ntspwlarvq ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtX . jbfykaxbhu ; rt_LoggedStateSignalPtrs [ 4 ] = ( void * ) & rtDW . j45svihtjo ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "tmp_raccel_xout" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 2 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; { static void * rt_LoggedOutputSignalPtrs [ ] = { & rtY . ggwcqiyygf } ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( ( LogSignalPtrsType ) rt_LoggedOutputSignalPtrs ) ) ; } { static int_T rt_LoggedOutputWidths [ ] = { 1 } ; static int_T rt_LoggedOutputNumDimensions [ ] = { 1 } ; static int_T rt_LoggedOutputDimensions [ ] = { 1 } ; static boolean_T rt_LoggedOutputIsVarDims [ ] = { 0 } ; static void * rt_LoggedCurrentSignalDimensions [ ] = { ( NULL ) } ; static int_T rt_LoggedCurrentSignalDimensionsSize [ ] = { 4 } ; static BuiltInDTypeId rt_LoggedOutputDataTypeIds [ ] = { SS_DOUBLE } ; static int_T rt_LoggedOutputComplexSignals [ ] = { 0 } ; static RTWPreprocessingFcnPtr rt_LoggingPreprocessingFcnPtrs [ ] = { ( NULL ) } ; static const char_T * rt_LoggedOutputLabels [ ] = { "" } ; static const char_T * rt_LoggedOutputBlockNames [ ] = { "LKA_T_staliro/Output" } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static RTWLogSignalInfo rt_LoggedOutputSignalInfo [ ] = { { 1 , rt_LoggedOutputWidths , rt_LoggedOutputNumDimensions , rt_LoggedOutputDimensions , rt_LoggedOutputIsVarDims , rt_LoggedCurrentSignalDimensions , rt_LoggedCurrentSignalDimensionsSize , rt_LoggedOutputDataTypeIds , rt_LoggedOutputComplexSignals , ( NULL ) , rt_LoggingPreprocessingFcnPtrs , { rt_LoggedOutputLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedOutputBlockNames } , { ( NULL ) } , ( NULL ) , rt_RTWLogDataTypeConvert , ( NULL ) } } ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , rt_LoggedOutputSignalInfo ) ; rt_LoggedCurrentSignalDimensions [ 0 ] = & rt_LoggedOutputWidths [ 0 ] ; } rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "tmp_raccel_yout1" ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static boolean_T contStatesDisabled [ 4 ] ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 7 ] = { { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . cvvfihfwkh ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . jufm00blrf ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . bfv1nrsihf ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . pend3mkk21 ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . ncih2tph21 ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . o13qcxbdip ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . k0suforjme ) , ( NULL ) } } ; ssSetNumNonContDerivSigInfos ( rtS , 7 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "ode3" ) ; ssSetVariableStepSolver ( rtS , 0 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; } ssSetChecksumVal ( rtS , 0 , 2717182362U ) ; ssSetChecksumVal ( rtS , 1 , 1965175627U ) ; ssSetChecksumVal ( rtS , 2 , 3343308624U ) ; ssSetChecksumVal ( rtS , 3 , 1323682619U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 23 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; systemRan [ 5 ] = & rtAlwaysEnabled ; systemRan [ 6 ] = & rtAlwaysEnabled ; systemRan [ 7 ] = & rtAlwaysEnabled ; systemRan [ 8 ] = & rtAlwaysEnabled ; systemRan [ 9 ] = & rtAlwaysEnabled ; systemRan [ 10 ] = & rtAlwaysEnabled ; systemRan [ 11 ] = & rtAlwaysEnabled ; systemRan [ 12 ] = & rtAlwaysEnabled ; systemRan [ 13 ] = & rtAlwaysEnabled ; systemRan [ 14 ] = & rtAlwaysEnabled ; systemRan [ 15 ] = & rtAlwaysEnabled ; systemRan [ 16 ] = & rtAlwaysEnabled ; systemRan [ 17 ] = & rtAlwaysEnabled ; systemRan [ 18 ] = & rtAlwaysEnabled ; systemRan [ 19 ] = & rtAlwaysEnabled ; systemRan [ 20 ] = & rtAlwaysEnabled ; systemRan [ 21 ] = & rtAlwaysEnabled ; systemRan [ 22 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_LKA_T_staliro_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_LKA_T_staliro_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_LKA_T_staliro_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID2 ( tid ) ; }
