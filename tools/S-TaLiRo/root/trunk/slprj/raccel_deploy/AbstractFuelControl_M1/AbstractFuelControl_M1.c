#include "AbstractFuelControl_M1.h"
#include <stddef.h>
#include "rtwtypes.h"
#include "AbstractFuelControl_M1_private.h"
#include "mwmathutil.h"
#include <float.h>
#include "rt_logging_mmi.h"
#include "AbstractFuelControl_M1_capi.h"
#include "zero_crossing_types.h"
#include "AbstractFuelControl_M1_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; extern ssExecutionInfo gblExecutionInfo ; RTWExtModeInfo *
gblRTWExtModeInfo = NULL ; void raccelForceExtModeShutdown ( boolean_T
extModeStartPktReceived ) { if ( ! extModeStartPktReceived ) { boolean_T
stopRequested = false ; rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 3 , &
stopRequested ) ; } rtExtModeShutdown ( 3 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 4 ; const char_T
* gbl_raccel_Version = "24.2 (R2024b) 21-Jun-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
B rtB ; X rtX ; DW rtDW ; PrevZCX rtPrevZCX ; ExtU rtU ; ExtY rtY ; static
SimStruct model_S ; SimStruct * const rtS = & model_S ;
#ifndef __RTW_UTFREE__  
extern void * utMalloc ( size_t ) ;
#endif
void * rt_TDelayCreateBuf ( int_T numBuffer , int_T bufSz , int_T elemSz ) {
return ( ( void * ) utMalloc ( numBuffer * bufSz * elemSz ) ) ; }
#ifndef __RTW_UTFREE__  
extern void * utMalloc ( size_t ) ; extern void utFree ( void * ) ;
#endif
boolean_T rt_TDelayUpdateTailOrGrowBuf ( int_T * bufSzPtr , int_T * tailPtr ,
int_T * headPtr , int_T * lastPtr , real_T tMinusDelay , real_T * * uBufPtr ,
boolean_T isfixedbuf , boolean_T istransportdelay , int_T * maxNewBufSzPtr )
{ int_T testIdx ; int_T tail = * tailPtr ; int_T bufSz = * bufSzPtr ; real_T
* tBuf = * uBufPtr + bufSz ; real_T * xBuf = ( NULL ) ; int_T numBuffer = 2 ;
if ( istransportdelay ) { numBuffer = 3 ; xBuf = * uBufPtr + 2 * bufSz ; }
testIdx = ( tail < ( bufSz - 1 ) ) ? ( tail + 1 ) : 0 ; if ( ( tMinusDelay <=
tBuf [ testIdx ] ) && ! isfixedbuf ) { int_T j ; real_T * tempT ; real_T *
tempU ; real_T * tempX = ( NULL ) ; real_T * uBuf = * uBufPtr ; int_T
newBufSz = bufSz + 1024 ; if ( newBufSz > * maxNewBufSzPtr ) { *
maxNewBufSzPtr = newBufSz ; } tempU = ( real_T * ) utMalloc ( numBuffer *
newBufSz * sizeof ( real_T ) ) ; if ( tempU == ( NULL ) ) { return ( false )
; } tempT = tempU + newBufSz ; if ( istransportdelay ) tempX = tempT +
newBufSz ; for ( j = tail ; j < bufSz ; j ++ ) { tempT [ j - tail ] = tBuf [
j ] ; tempU [ j - tail ] = uBuf [ j ] ; if ( istransportdelay ) tempX [ j -
tail ] = xBuf [ j ] ; } for ( j = 0 ; j < tail ; j ++ ) { tempT [ j + bufSz -
tail ] = tBuf [ j ] ; tempU [ j + bufSz - tail ] = uBuf [ j ] ; if ( istransportdelay ) tempX [ j + bufSz - tail ] = xBuf [ j ] ; } if ( * lastPtr > tail ) { * lastPtr -= tail ; } else { * lastPtr += ( bufSz - tail ) ; } * tailPtr = 0 ; * headPtr = bufSz ; utFree ( uBuf ) ; * bufSzPtr = newBufSz ; * uBufPtr = tempU ; } else { * tailPtr = testIdx ; } return ( true ) ; } real_T rt_VTDelayfindtDInterpolate ( real_T x , real_T * uBuf , int_T bufSz , int_T head , int_T tail , int_T * pLast , real_T t , real_T tStart , boolean_T discrete , boolean_T minorStepAndTAtLastMajorOutput , real_T initOutput , real_T * appliedDelay ) { int_T n , k ; real_T f ; int_T kp1 ; real_T tminustD = 0 ; real_T tL = 0 ; real_T tR = 0 ; real_T uL = 0 ; real_T uR = 0 ; real_T uD , fU ; real_T * tBuf = uBuf + bufSz ; real_T * xBuf = uBuf + 2 * bufSz ; if ( minorStepAndTAtLastMajorOutput ) { if ( * pLast == head ) { * pLast = ( * pLast == 0 ) ? bufSz - 1 : * pLast - 1 ; } head = ( head == 0 ) ? bufSz - 1 : head - 1 ; } if ( x <= 1 ) { return initOutput ; } k = * pLast ; n = 0 ; for ( ; ; ) { n ++ ; if ( n > bufSz ) break ; if ( x - xBuf [ k ] > 1.0 ) { if ( k == head ) { int_T km1 ; f = ( x - 1.0 - xBuf [ k ] ) / ( x - xBuf [ k ] ) ; tminustD = ( 1.0 - f ) * tBuf [ k ] + f * t ; km1 = k - 1 ; if ( km1 < 0 ) km1 = bufSz - 1 ; tL = tBuf [ km1 ] ; tR = tBuf [ k ] ; uL = uBuf [ km1 ] ; uR = uBuf [ k ] ; break ; } kp1 = k + 1 ; if ( kp1 == bufSz ) kp1 = 0 ; if ( x - xBuf [ kp1 ] <= 1.0 ) { f = ( x - 1.0 - xBuf [ k ] ) / ( xBuf [ kp1 ] - xBuf [ k ] ) ; tL = tBuf [ k ] ; tR = tBuf [ kp1 ] ; uL = uBuf [ k ] ; uR = uBuf [ kp1 ] ; tminustD = ( 1.0 - f ) * tL + f * tR ; break ; } k = kp1 ; } else { if ( k == tail ) { f = ( x - 1.0 ) / xBuf [ k ] ; if ( discrete ) { return ( uBuf [ tail ] ) ; } kp1 = k + 1 ; if ( kp1 == bufSz ) kp1 = 0 ; tminustD = ( 1 - f ) * tStart + f * tBuf [ k ] ; tL = tBuf [ k ] ; tR = tBuf [ kp1 ] ; uL = uBuf [ k ] ; uR = uBuf [ kp1 ] ; break ; } k = k - 1 ; if ( k < 0 ) k = bufSz - 1 ; } } * pLast = k ; if ( tR == tL ) { fU = 1.0 ; } else { fU = ( tminustD - tL ) / ( tR - tL ) ; } if ( discrete ) { uD = ( fU > ( 1.0 - fU ) ) ? uR : uL ; } else { uD = ( 1.0 - fU ) * uL + fU * uR ; } * appliedDelay = t - tminustD ; return uD ; }
#ifndef __RTW_UTFREE__  
extern void utFree ( void * ) ;
#endif
void rt_TDelayFreeBuf ( void * buf ) { utFree ( buf ) ; } real_T
look2_binlxpw ( real_T u0 , real_T u1 , const real_T bp0 [ ] , const real_T
bp1 [ ] , const real_T table [ ] , const uint32_T maxIndex [ ] , uint32_T
stride ) { real_T fractions [ 2 ] ; real_T frac ; real_T yL_0d0 ; real_T
yL_0d1 ; uint32_T bpIndices [ 2 ] ; uint32_T bpIdx ; uint32_T iLeft ;
uint32_T iRght ; if ( u0 <= bp0 [ 0U ] ) { iLeft = 0U ; frac = ( u0 - bp0 [
0U ] ) / ( bp0 [ 1U ] - bp0 [ 0U ] ) ; } else if ( u0 < bp0 [ maxIndex [ 0U ]
] ) { bpIdx = maxIndex [ 0U ] >> 1U ; iLeft = 0U ; iRght = maxIndex [ 0U ] ;
while ( iRght - iLeft > 1U ) { if ( u0 < bp0 [ bpIdx ] ) { iRght = bpIdx ; }
else { iLeft = bpIdx ; } bpIdx = ( iRght + iLeft ) >> 1U ; } frac = ( u0 -
bp0 [ iLeft ] ) / ( bp0 [ iLeft + 1U ] - bp0 [ iLeft ] ) ; } else { iLeft =
maxIndex [ 0U ] - 1U ; frac = ( u0 - bp0 [ maxIndex [ 0U ] - 1U ] ) / ( bp0 [
maxIndex [ 0U ] ] - bp0 [ maxIndex [ 0U ] - 1U ] ) ; } fractions [ 0U ] =
frac ; bpIndices [ 0U ] = iLeft ; if ( u1 <= bp1 [ 0U ] ) { iLeft = 0U ; frac
= ( u1 - bp1 [ 0U ] ) / ( bp1 [ 1U ] - bp1 [ 0U ] ) ; } else if ( u1 < bp1 [
maxIndex [ 1U ] ] ) { bpIdx = maxIndex [ 1U ] >> 1U ; iLeft = 0U ; iRght =
maxIndex [ 1U ] ; while ( iRght - iLeft > 1U ) { if ( u1 < bp1 [ bpIdx ] ) {
iRght = bpIdx ; } else { iLeft = bpIdx ; } bpIdx = ( iRght + iLeft ) >> 1U ;
} frac = ( u1 - bp1 [ iLeft ] ) / ( bp1 [ iLeft + 1U ] - bp1 [ iLeft ] ) ; }
else { iLeft = maxIndex [ 1U ] - 1U ; frac = ( u1 - bp1 [ maxIndex [ 1U ] -
1U ] ) / ( bp1 [ maxIndex [ 1U ] ] - bp1 [ maxIndex [ 1U ] - 1U ] ) ; } bpIdx
= iLeft * stride + bpIndices [ 0U ] ; yL_0d0 = table [ bpIdx ] ; yL_0d0 += ( table [ bpIdx + 1U ] - yL_0d0 ) * fractions [ 0U ] ; bpIdx += stride ; yL_0d1 = table [ bpIdx ] ; return ( ( ( table [ bpIdx + 1U ] - yL_0d1 ) * fractions [ 0U ] + yL_0d1 ) - yL_0d0 ) * frac + yL_0d0 ; } void MdlInitialize ( void ) { rtX . oxpohnjabn = rtP . Integrator_IC ; rtX . dixd3f2rcr = 0.0 ; rtX . ew102iggpt = rtP . p00543bar_IC ; rtX . mnpnqi1mo5 = rtP . Integrator_IC_lkhrhjwbot ; rtX . afa2wi01oy = rtP . Integrator_IC_mrk54afxwh ; rtX . ngshao3zxa = 0.0 ; rtDW . dx43c5auhv = rtP . UnitDelay_InitialCondition ; rtDW . btjp423gxi = rtP . UnitDelay2_InitialCondition ; rtDW . ikdfizkwpn = rtP . UnitDelay1_InitialCondition_chrxrrvhjp ; rtDW . e50m41o2zc = rtP . UnitDelay1_InitialCondition_f1k0xy35kz ; rtDW . lq35xsrymr = rtP . UnitDelay1_InitialCondition ; rtDW . lgypi2y43m = rtP . UnitDelay1_InitialCondition_lwvhtplh3d ; rtX . ed33yoocaq = rtP . Integrator_IC_b500ztwhjo ; } void MdlEnable ( void ) { rtDW . gh1igxnqfd = 1 ; _ssSetSampleHit ( rtS , 2 , 1 ) ; _ssSetTaskTime ( rtS , 2 , ssGetT ( rtS ) ) ; _ssSetVarNextHitTime ( rtS , 0 , ssGetT ( rtS ) ) ; ; } void MdlStart ( void ) { { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { rtwISigstreamManagerSetDestinationBase ( pISigstreamManager , 0 , & rtU . okzizglgcx ) ; rtwISigstreamManagerSetDestinationBase ( pISigstreamManager , 1 , & rtU . czen2q1qls ) ; } } rtDW . lcyc3z0xe4 = rtP . DataStoreMemory_InitialValue ; rtDW . oyzwbyjehp = rtP . DataStoreMemory1_InitialValue ; rtDW . abqwkmfwm4 = rtP . DataStoreMemory2_InitialValue ; rtDW . kasy120l4j = rtP . DataStoreMemory3_InitialValue ; rtDW . j3e50spkrk = rtP . commanded_fuel_InitialValue ; rtDW . gqihgtfesf = rtP . mode_fb_InitialValue ; rtDW . fpmlnohs30 = rtP . mode_fb1_InitialValue ; { int_T j ; char_T ptrKey [ 1024 ] ; { real_T * pBuffer = ( real_T * ) rt_TDelayCreateBuf ( 3 , 20480 , sizeof ( real_T ) ) ; if ( pBuffer == ( NULL ) ) { ssSetErrorStatus ( rtS , "vtdelay memory allocation error" ) ; return ; } rtDW . amxtebsuok . Tail = 0 ; rtDW . amxtebsuok . Head = 0 ; rtDW . amxtebsuok . Last = 0 ; rtDW . amxtebsuok . CircularBufSize = 20480 ; for ( j = 0 ; j < 20480 ; j ++ ) { pBuffer [ j ] = rtP . fuelsystemtransportdelay_InitOutput ; pBuffer [ 20480 + j ] = ssGetT ( rtS ) ; } pBuffer [ 2 * 20480 ] = 0.0 ; rtDW . gpxkxxnpkk . TUbufferPtrs [ 0 ] = ( void * ) & pBuffer [ 0 ] ; sprintf ( ptrKey , "AbstractFuelControl_M1/Model 1/Cylinder and Exhaust/fuel system transport delay_TUbuffer%d" , 0 ) ; slsaSaveRawMemoryForSimTargetOP ( rtS , ptrKey , ( void * * ) ( & rtDW . gpxkxxnpkk . TUbufferPtrs [ 0 ] ) , 3 * 20480 * sizeof ( real_T ) , ( NULL ) , ( NULL ) ) ; } } rtDW . haix1u4b0d = false ; ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; rtDW . d1wjbe2mwx = 0 ; ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; rtDW . f2jjc1wq2q = - 1 ; MdlInitialize ( ) ; MdlEnable ( ) ; } void MdlOutputs ( int_T tid ) { real_T ratio ; real_T taskTimeV ; real32_T bgzatajtc2 ; real32_T bjr2sk4jcq ; real32_T bxuwegyioz ; uint32_T numCycles ; int8_T rtAction ; int8_T rtPrevAction ; boolean_T a0oiycvwza ; boolean_T axyucx4qqa ; boolean_T k4ujyrkvho ; ZCEventType zcEvent ; if ( gblExecutionInfo . gblObjects_ . inportFileName != ( NULL ) ) { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( slIsRapidAcceleratorSimulating ( ) && externalInputIsInDatasetFormat ) { const int maxErrorBufferSize = 16384 ; char_T errMsg [ 16384 ] ; bool bSetErrorStatus = false ; if ( 1 ) { { real_T time = ssGetTaskTime ( rtS , 0 ) ; if ( ! rtwISigstreamManagerIsPeriodicFcnCall ( pISigstreamManager , 0 ) ) { int_T sampleHit = 0U ; bSetErrorStatus = rtwISigstreamManagerInjectDataMultiRate ( pISigstreamManager , 0 , time , 1 , "<Root>/Engine Speed (rpm)" , "inputTimeseries" , & sampleHit , errMsg , maxErrorBufferSize ) ; } } } if ( 1 ) { { real_T time = ssGetTaskTime ( rtS , 0 ) ; if ( ! rtwISigstreamManagerIsPeriodicFcnCall ( pISigstreamManager , 1 ) ) { int_T sampleHit = 0U ; bSetErrorStatus = rtwISigstreamManagerInjectDataMultiRate ( pISigstreamManager , 1 , time , 1 , "<Root>/Throttle angle" , "inputTimeseries" , & sampleHit , errMsg , maxErrorBufferSize ) ; } } } if ( bSetErrorStatus ) { ssSetErrorStatus ( rtS , errMsg ) ; return ; } } else { int_T currTimeIdx ; int_T i ; if ( gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . nTimePoints > 0 ) { if ( 1 ) { { real_T time = ssGetTaskTime ( rtS , 0 ) ; int k = 1 ; if ( gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . nTimePoints == 1 ) { k = 0 ; } currTimeIdx = rt_getTimeIdx ( gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . time , time , gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . nTimePoints , * ( gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . currTimeIdx ) , 1 , 0 ) ; ( * gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . currTimeIdx ) = currTimeIdx ; for ( i = 0 ; i < 1 ; i ++ ) { real_T * realPtr1 = ( real_T * ) gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . ur + i * gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . nTimePoints + currTimeIdx ; real_T * realPtr2 = realPtr1 + 1 * k ; ( void ) rt_Interpolate_Datatype ( realPtr1 , realPtr2 , & rtU . okzizglgcx , time , gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . time [ currTimeIdx ] , gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . time [ currTimeIdx + k ] , gblExecutionInfo . gblObjects_ . inportTUtables [ 0 ] . uDataType ) ; } } } } if ( gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . nTimePoints > 0 ) { if ( 1 ) { { real_T time = ssGetTaskTime ( rtS , 0 ) ; int k = 1 ; if ( gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . nTimePoints == 1 ) { k = 0 ; } currTimeIdx = rt_getTimeIdx ( gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . time , time , gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . nTimePoints , * ( gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . currTimeIdx ) , 1 , 0 ) ; ( * gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . currTimeIdx ) = currTimeIdx ; for ( i = 0 ; i < 1 ; i ++ ) { real_T * realPtr1 = ( real_T * ) gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . ur + i * gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . nTimePoints + currTimeIdx ; real_T * realPtr2 = realPtr1 + 1 * k ; ( void ) rt_Interpolate_Datatype ( realPtr1 , realPtr2 , & rtU . czen2q1qls , time , gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . time [ currTimeIdx ] , gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . time [ currTimeIdx + k ] , gblExecutionInfo . gblObjects_ . inportTUtables [ 1 ] . uDataType ) ; } } } } } } srClearBC ( rtDW . meym2kkggb ) ; srClearBC ( rtDW . nhy3an0buu ) ; srClearBC ( rtDW . ev00g24oaq ) ; srClearBC ( rtDW . lxkp2jo22h ) ; srClearBC ( rtDW . bkxvh1udvf ) ; srClearBC ( rtDW . lkimmiwkfm ) ; srClearBC ( rtDW . imhks3haia ) ; rtB . no3zx0ezfz = rtX . oxpohnjabn ; rtB . cqfpshtxvd = rtP . AF_sensor_Gain * rtB . no3zx0ezfz ; rtB . pkw2gccdta = 0.0 ; rtB . pkw2gccdta += rtP . Throttledelay_C * rtX . dixd3f2rcr ; rtB . klp4ythknn = rtB . pkw2gccdta + rtP . Baseopeningangle_Value ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . i1d01tl30y = rtB . klp4ythknn >= rtP . theta090_UpperSat ? 1 : rtB . klp4ythknn > rtP . theta090_LowerSat ? 0 : - 1 ; } rtB . mgqkkfzlvr = rtDW . i1d01tl30y == 1 ? rtP . theta090_UpperSat : rtDW . i1d01tl30y == - 1 ? rtP . theta090_LowerSat : rtB . klp4ythknn ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . kmsrw41wv2 = rtU . okzizglgcx >= rtP . EngineSpeed9001100_UpperSat ? 1 : rtU . okzizglgcx > rtP . EngineSpeed9001100_LowerSat ? 0 : - 1 ; } rtB . adzxmfdvct = rtDW . kmsrw41wv2 == 1 ? rtP . EngineSpeed9001100_UpperSat : rtDW . kmsrw41wv2 == - 1 ? rtP . EngineSpeed9001100_LowerSat : rtU . okzizglgcx ; rtB . b0hwckgura = rtP . rpmtorads_Gain * rtB . adzxmfdvct ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . ori3ob0wbj = ( ssGetTaskTime ( rtS , 1 ) >= rtP . fault_time ) ; if ( rtDW . ori3ob0wbj == 1 ) { rtB . kx21h31n2g = rtP . AFSensorFaultInjection_YFinal ; } else { rtB . kx21h31n2g = rtP . AFSensorFaultInjection_Y0 ; } } if ( rtB . kx21h31n2g >= rtP . Switch_Threshold ) { rtB . lmmtdwu0wp = rtP . FaultySensorOutput_Value ; } else { rtB . lmmtdwu0wp = rtB . cqfpshtxvd ; } rtB . e0hefnwpn5 = rtP . AF_sensor_tol * rtB . lmmtdwu0wp ; rtB . dbtddmdnlk = ( real32_T ) rtB . b0hwckgura ; rtB . g1kfu2k5fh = ( real32_T ) rtB . mgqkkfzlvr ; rtB . jccvex1ixq = rtX . ew102iggpt ; rtB . fskykcddjv = rtB . jccvex1ixq / rtP . AtmosphericPressurebar_Value ; rtB . p0vdharg3x = 1.0 / rtB . jccvex1ixq * rtP . AtmosphericPressurebar_Value ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtB . kvvecvkv4w = rtB . fskykcddjv ; rtDW . jtmvk2k11t = 0 ; if ( ( rtB . fskykcddjv != rtB . fskykcddjv ) || ( rtB . p0vdharg3x < rtB . fskykcddjv ) ) { rtB . kvvecvkv4w = rtB . p0vdharg3x ; rtDW . jtmvk2k11t = 1 ; } rtDW . lqflcq5fag = ( rtB . kvvecvkv4w >= rtP . Switch_Threshold_g5ldd2qgcy ) ; } else { rtB . kvvecvkv4w = rtB . fskykcddjv ; if ( rtDW . jtmvk2k11t == 1 ) { rtB . kvvecvkv4w = rtB . p0vdharg3x ; } } if ( rtDW . lqflcq5fag ) { taskTimeV = rtB . kvvecvkv4w - rtB . kvvecvkv4w * rtB . kvvecvkv4w ; if ( taskTimeV < 0.0 ) { taskTimeV = - muDoubleScalarSqrt ( - taskTimeV ) ; } else { taskTimeV = muDoubleScalarSqrt ( taskTimeV ) ; } rtB . g1ctig4m3i = 2.0 * taskTimeV ; rtB . d2xczoi00g = rtB . g1ctig4m3i ; } else { rtB . d2xczoi00g = rtP . SonicFlow_Value ; } rtB . mqlyzq05s5 = rtP . AtmosphericPressurebar_Value - rtB . jccvex1ixq ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtB . mqlyzq05s5 > 0.0 ) { rtDW . g33icp3oa5 = 1 ; } else if ( rtB . mqlyzq05s5 < 0.0 ) { rtDW . g33icp3oa5 = - 1 ; } else { rtDW . g33icp3oa5 = 0 ; } rtB . edkdzixy33 = rtDW . g33icp3oa5 ; } rtB . jrd3m1e14e = ( ( ( 2.821 - 0.05231 * rtB . mgqkkfzlvr ) + 0.10299 * rtB . mgqkkfzlvr * rtB . mgqkkfzlvr ) - 0.00063 * rtB . mgqkkfzlvr * rtB . mgqkkfzlvr * rtB . mgqkkfzlvr ) * rtB . d2xczoi00g * rtB . edkdzixy33 ; rtB . dv5kghuyay = rtP . MAF_sensor_tol * rtB . jrd3m1e14e ; rtB . hto3u2ooh4 = ( real32_T ) rtB . dv5kghuyay ; rtB . j0q4aipzzu = ( real32_T ) rtB . e0hefnwpn5 ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . lm0jugnir2 = ( ssGetTaskTime ( rtS , 1 ) >= rtP . Pwon_Time ) ; if ( rtDW . lm0jugnir2 == 1 ) { rtB . ak0qj52dtk = rtP . Pwon_YFinal ; } else { rtB . ak0qj52dtk = rtP . Pwon_Y0 ; } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { taskTimeV = ssGetTaskTime ( rtS , 2 ) ; if ( ssGetTNextWasAdjusted ( rtS , 2 ) ) { rtDW . owav32xvsn = _ssGetVarNextHitTime ( rtS , 0 ) ; } if ( rtDW . gh1igxnqfd != 0 ) { rtDW . gh1igxnqfd = 0 ; if ( taskTimeV >= rtP . PulseGenerator_10ms_PhaseDelay ) { ratio = ( taskTimeV - rtP . PulseGenerator_10ms_PhaseDelay ) / rtP . PulseGenerator_10ms_Period ; numCycles = ( uint32_T ) muDoubleScalarFloor ( ratio ) ; if ( muDoubleScalarAbs ( ( real_T ) ( numCycles + 1U ) - ratio ) < DBL_EPSILON * ratio ) { numCycles ++ ; } rtDW . a2qsprdgu1 = numCycles ; ratio = ( ( real_T ) numCycles * rtP . PulseGenerator_10ms_Period + rtP . PulseGenerator_10ms_PhaseDelay ) + rtP . PulseGenerator_10ms_Duty * rtP . PulseGenerator_10ms_Period / 100.0 ; if ( taskTimeV < ratio ) { rtDW . enr4nh0hfz = 1 ; rtDW . owav32xvsn = ratio ; } else { rtDW . enr4nh0hfz = 0 ; rtDW . owav32xvsn = ( real_T ) ( numCycles + 1U ) * rtP . PulseGenerator_10ms_Period + rtP . PulseGenerator_10ms_PhaseDelay ; } } else { rtDW . a2qsprdgu1 = rtP . PulseGenerator_10ms_PhaseDelay != 0.0 ? - 1 : 0 ; rtDW . enr4nh0hfz = 0 ; rtDW . owav32xvsn = rtP . PulseGenerator_10ms_PhaseDelay ; } } else if ( rtDW . owav32xvsn <= taskTimeV ) { if ( rtDW . enr4nh0hfz == 1 ) { rtDW . enr4nh0hfz = 0 ; rtDW . owav32xvsn = ( real_T ) ( rtDW . a2qsprdgu1 + 1L ) * rtP . PulseGenerator_10ms_Period + rtP . PulseGenerator_10ms_PhaseDelay ; } else { rtDW . a2qsprdgu1 ++ ; rtDW . enr4nh0hfz = 1 ; rtDW . owav32xvsn = ( rtP . PulseGenerator_10ms_Duty * rtP . PulseGenerator_10ms_Period * 0.01 + ( real_T ) rtDW . a2qsprdgu1 * rtP . PulseGenerator_10ms_Period ) + rtP . PulseGenerator_10ms_PhaseDelay ; } } _ssSetVarNextHitTime ( rtS , 0 , rtDW . owav32xvsn ) ; if ( rtDW . enr4nh0hfz == 1 ) { rtB . mdypthjkfn = rtP . PulseGenerator_10ms_Amp ; } else { rtB . mdypthjkfn = 0.0 ; } } rtDW . lcyc3z0xe4 = rtB . dbtddmdnlk ; rtDW . kasy120l4j = rtB . g1kfu2k5fh ; rtDW . oyzwbyjehp = rtB . hto3u2ooh4 ; rtDW . abqwkmfwm4 = rtB . j0q4aipzzu ; if ( ssIsSampleHit ( rtS , 1 , 0 ) && ssIsModeUpdateTimeStep ( rtS ) ) { zcEvent = rt_ZCFcn ( RISING_ZERO_CROSSING , & rtPrevZCX . edwiftu20j , ( rtB . ak0qj52dtk ) ) ; if ( zcEvent != NO_ZCEVENT ) { rtDW . gqihgtfesf = ( rtP . Constant1_Value_ln0tldisjx != 0.0F ) ; rtDW . j3e50spkrk = rtP . Constant2_Value_ki5yoscsu1 ; if ( ssIsMajorTimeStep ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; } rtDW . fpmlnohs30 = rtP . Constant3_Value_old4tikkcg ; if ( ssIsMajorTimeStep ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; } rtDW . lxkp2jo22h = 4 ; } zcEvent = rt_ZCFcn ( RISING_ZERO_CROSSING , & rtPrevZCX . behaxxarnb , ( rtB . mdypthjkfn ) ) ; if ( zcEvent != NO_ZCEVENT ) { axyucx4qqa = ( ( rtDW . abqwkmfwm4 <= rtP . threshold_Value ) || rtDW . dx43c5auhv ) ; bgzatajtc2 = rtDW . btjp423gxi + rtP . sampling_sec_Value ; k4ujyrkvho = ( ( bgzatajtc2 >= rtP . normal_mode_start_sec_Value ) || rtDW . ikdfizkwpn ) ; if ( rtDW . e50m41o2zc ) { bjr2sk4jcq = rtP . Constant_Value_d4xw1fezi3 ; } else { bjr2sk4jcq = rtB . fxvkky4cdu ; } a0oiycvwza = ( rtDW . kasy120l4j >= bjr2sk4jcq ) ; rtDW . gqihgtfesf = ( axyucx4qqa || ( ! k4ujyrkvho ) || a0oiycvwza ) ; if ( k4ujyrkvho && a0oiycvwza ) { rtDW . fpmlnohs30 = rtP . airbyfuel_reference_power_Value ; } else { rtDW . fpmlnohs30 = rtP . airbyfuel_reference_Value ; } if ( ssIsMajorTimeStep ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; } rtDW . dx43c5auhv = axyucx4qqa ; rtDW . btjp423gxi = bgzatajtc2 ; rtDW . ikdfizkwpn = k4ujyrkvho ; rtDW . e50m41o2zc = a0oiycvwza ; rtDW . ev00g24oaq = 4 ; } zcEvent = rt_ZCFcn ( RISING_ZERO_CROSSING , & rtPrevZCX . k23vkqx30c , ( rtB . mdypthjkfn ) ) ; if ( zcEvent != NO_ZCEVENT ) { bgzatajtc2 = ( ( rtDW . lq35xsrymr * rtDW . lcyc3z0xe4 * rtP . Constant3_Value + rtP . Constant2_Value ) + rtDW . lq35xsrymr * rtDW . lq35xsrymr * rtDW . lcyc3z0xe4 * rtP . Constant4_Value ) + rtDW . lcyc3z0xe4 * rtDW . lcyc3z0xe4 * rtDW . lq35xsrymr * rtP . Constant5_Value ; bjr2sk4jcq = ( rtDW . oyzwbyjehp - bgzatajtc2 ) * rtP . Gain_Gain_jfaopuunxi * rtP . Constant1_Value + rtDW . lq35xsrymr ; axyucx4qqa = ! rtDW . gqihgtfesf ; if ( axyucx4qqa ) { bxuwegyioz = rtDW . abqwkmfwm4 - rtDW . fpmlnohs30 ; rtB . g1sdxnua3f = rtP . Gain1_Gain_an2gitrlld * bxuwegyioz * rtP . Constant1_Value_h3gosz3rso + rtDW . lgypi2y43m ; rtB . hpdu0hetw0 = rtP . Gain_Gain_c5md433mqa * bxuwegyioz + rtB . g1sdxnua3f ; rtDW . meym2kkggb = 4 ; } if ( rtDW . gqihgtfesf ) { bxuwegyioz = rtP . Constant3_Value_ar1ajyxmim ; } else { bxuwegyioz = rtP . Constant2_Value_h15bkuhc3g + rtB . hpdu0hetw0 ; if ( bxuwegyioz > rtP . fb_fuel_saturation_UpperSat ) { bxuwegyioz = rtP . fb_fuel_saturation_UpperSat ; } else if ( bxuwegyioz < rtP . fb_fuel_saturation_LowerSat ) { bxuwegyioz = rtP . fb_fuel_saturation_LowerSat ; } } bgzatajtc2 = bgzatajtc2 / rtDW . fpmlnohs30 * bxuwegyioz ; if ( bgzatajtc2 > rtP . fuel_saturation_UpperSat ) { rtDW . j3e50spkrk = rtP . fuel_saturation_UpperSat ; } else if ( bgzatajtc2 < rtP . fuel_saturation_LowerSat ) { rtDW . j3e50spkrk = rtP . fuel_saturation_LowerSat ; } else { rtDW . j3e50spkrk = bgzatajtc2 ; } if ( ssIsMajorTimeStep ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; } rtDW . lq35xsrymr = bjr2sk4jcq ; if ( axyucx4qqa ) { rtDW . lgypi2y43m = rtB . g1sdxnua3f ; } rtDW . nhy3an0buu = 4 ; } } rtB . ige0xs0xi4 = rtDW . j3e50spkrk ; rtB . g4yktga2hl = rtDW . gqihgtfesf ; rtB . iwmpiqqojt = rtDW . fpmlnohs30 ; rtB . oftupsnnwq = rtX . mnpnqi1mo5 ; rtB . kdatkznqf3 = rtB . oftupsnnwq - rtB . no3zx0ezfz ; rtB . kzu4511fzw = rtP . Gain_Gain * rtB . kdatkznqf3 ; rtB . bq2aoymfa2 = ( ( ( 0.08979 * rtB . jccvex1ixq * rtB . b0hwckgura - 0.366 ) - 0.0337 * rtB . b0hwckgura * rtB . jccvex1ixq * rtB . jccvex1ixq ) + 0.0001 * rtB . jccvex1ixq * rtB . b0hwckgura * rtB . b0hwckgura ) * rtP . Gain2_Gain ; rtB . b0d12gfpcn = rtP . radstorpm_Gain * rtB . b0hwckgura ; rtB . ggljthsrvd = rtB . bq2aoymfa2 / rtB . b0hwckgura ; rtB . eklk3dmin0 = rtP . Gain_Gain_lwwetqjf5s * rtB . ggljthsrvd ; rtB . oo3ejug25p = rtP . Kappatolerance0911_Gain * look2_binlxpw ( rtB . b0d12gfpcn , rtB . eklk3dmin0 , rtP . uKappa_bp01Data , rtP . uKappa_bp02Data , rtP . uKappa_tableData , rtP . uKappa_maxIndex , 5U ) ; rtB . a0lpbr03kt = rtB . ige0xs0xi4 ; rtB . b3qds3z03d = rtP . fuel_inj_tol * rtB . a0lpbr03kt ; rtB . ojzkzpds5k = rtB . oo3ejug25p * rtB . b3qds3z03d ; rtB . fpznfvuttn = rtX . afa2wi01oy ; rtB . iefpdh24wc = rtP . tau_wwtolerance0911_Gain * look2_binlxpw ( rtB . b0d12gfpcn , rtB . eklk3dmin0 , rtP . tau_ww_bp01Data , rtP . tau_ww_bp02Data , rtP . tau_ww_tableData , rtP . tau_ww_maxIndex , 5U ) ; rtB . hdznuhk51n = rtB . fpznfvuttn / rtB . iefpdh24wc ; rtB . h2gumn0zfz = rtB . ojzkzpds5k + rtB . hdznuhk51n ; rtB . nfrioqoa1z = rtB . bq2aoymfa2 / rtB . h2gumn0zfz ; { real_T * * uBuffer = ( real_T * * ) & rtDW . gpxkxxnpkk . TUbufferPtrs [ 0 ] ; real_T simTime = ssGetT ( rtS ) ; real_T appliedDelay ; rtB . gh4si2bfc3 = rt_VTDelayfindtDInterpolate ( rtX . ngshao3zxa , * uBuffer , rtDW . amxtebsuok . CircularBufSize , rtDW . amxtebsuok . Head , rtDW . amxtebsuok . Tail , & rtDW . amxtebsuok . Last , simTime , 0.0 , 0 , ( boolean_T ) ( ssIsMinorTimeStep ( rtS ) && ( ( * uBuffer + rtDW . amxtebsuok . CircularBufSize ) [ rtDW . amxtebsuok . Head ] == ssGetT ( rtS ) ) ) , rtP . fuelsystemtransportdelay_InitOutput , & appliedDelay ) ; } rtB . nfkbndd5rw = rtB . gh4si2bfc3 - rtB . oftupsnnwq ; rtB . fthtwuev1r = rtP . Gain1_Gain * rtB . nfkbndd5rw ; rtB . inb2szn322 = rtP . radstorpm_Gain_phyjrb0ib3 * rtB . b0hwckgura ; rtB . f5wvyzcfg5 = look2_binlxpw ( rtB . inb2szn322 , rtB . eklk3dmin0 , rtP . delays_bp01Data , rtP . delays_bp02Data , rtP . delays_tableData , rtP . delays_maxIndex , 5U ) ; rtB . ok00lxzmk0 = rtB . jrd3m1e14e - rtB . bq2aoymfa2 ; rtB . keiyfhx4eg = rtP . RTVm_Gain * rtB . ok00lxzmk0 ; rtB . gczfrkzoxa = rtP . Gain_Gain_mq3vllxyxc * rtB . oo3ejug25p ; rtB . c3siktwmor = rtB . gczfrkzoxa + rtP . Constant_Value ; rtB . aexnc2oizh = rtB . b3qds3z03d * rtB . c3siktwmor ; rtB . eulxbwi45w = rtB . aexnc2oizh - rtB . hdznuhk51n ; rtB . j1xad1kw2y = rtB . iwmpiqqojt ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . gw2nevades = ( ssGetTaskTime ( rtS , 1 ) >= rtP . measureTime ) ; if ( rtDW . gw2nevades == 1 ) { taskTimeV = rtP . MeasureOn_YFinal_nzkifqrhnv ; } else { taskTimeV = rtP . MeasureOn_Y0_mao34pee2i ; } rtB . fhrdrehs2q = ( taskTimeV > rtP . Constant_Value_loxo21kpgj ) ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { if ( rtB . fhrdrehs2q ) { if ( ! rtDW . haix1u4b0d ) { if ( ssGetTaskTime ( rtS , 1 ) != ssGetTStart ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 0 , 1 * sizeof ( boolean_T ) ) ; rtDW . haix1u4b0d = true ; } } else { if ( ssGetTaskTime ( rtS , 1 ) == ssGetTStart ( rtS ) ) { ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; } if ( rtDW . haix1u4b0d ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; if ( ssGetTaskTime ( rtS , 0 ) == ssGetTStart ( rtS ) ) { ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; } if ( rtDW . f2jjc1wq2q == 1 ) { ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; } rtDW . f2jjc1wq2q = - 1 ; rtDW . haix1u4b0d = false ; } } } } if ( rtDW . haix1u4b0d ) { rtPrevAction = rtDW . f2jjc1wq2q ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { switch ( rtP . spec_num ) { case 1 : rtAction = 0 ; break ; case 2 : rtAction = 1 ; break ; default : rtAction = 2 ; break ; } rtDW . f2jjc1wq2q = rtAction ; } else { rtAction = rtDW . f2jjc1wq2q ; } if ( ( ssGetTaskTime ( rtS , 0 ) == ssGetTStart ( rtS ) ) && ssIsModeUpdateTimeStep ( rtS ) ) { ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; } if ( rtPrevAction != rtAction ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; if ( rtPrevAction == 1 ) { ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 1 , 1 * sizeof ( boolean_T ) ) ; } } switch ( rtAction ) { case 0 : if ( ( rtAction != rtPrevAction ) && ( ssGetTaskTime ( rtS , 0 ) != ssGetTStart ( rtS ) ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } rtB . ljxgkjd15j = rtB . cqfpshtxvd / rtB . j1xad1kw2y ; rtB . escvsqytg5 = rtB . ljxgkjd15j - rtP . Constant_Value_i2zubjcpp0 ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { srUpdateBC ( rtDW . bkxvh1udvf ) ; } break ; case 1 : if ( rtAction != rtPrevAction ) { if ( ssGetTaskTime ( rtS , 0 ) != ssGetTStart ( rtS ) ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } ( void ) memset ( & ( ( ( XDis * ) ssGetContStateDisabled ( rtS ) ) -> ed33yoocaq ) , 0 , 1 * sizeof ( boolean_T ) ) ; } rtB . cfq25lfyyw = rtX . ed33yoocaq ; rtB . l1nevfnqpf = rtB . cfq25lfyyw / ( rtP . simTime - 10.0 ) ; rtB . oyuelozcmi = rtB . cqfpshtxvd - rtB . j1xad1kw2y ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . beov4p1chl = ( ssGetTaskTime ( rtS , 1 ) >= rtP . MeasureOn_Time ) ; if ( rtDW . beov4p1chl == 1 ) { rtB . dizvn0c2kv = rtP . MeasureOn_YFinal ; } else { rtB . dizvn0c2kv = rtP . MeasureOn_Y0 ; } } rtB . p2z1c52id3 = rtB . oyuelozcmi * rtB . oyuelozcmi * rtB . dizvn0c2kv ; if ( ssIsMajorTimeStep ( rtS ) ) { if ( rtDW . d1wjbe2mwx != 0 ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; ssSetContTimeOutputInconsistentWithStateAtMajorStep ( rtS ) ; rtDW . d1wjbe2mwx = 0 ; } rtB . pqjo5cmif3 = muDoubleScalarSqrt ( rtB . l1nevfnqpf ) ; } else if ( rtB . l1nevfnqpf < 0.0 ) { rtB . pqjo5cmif3 = - muDoubleScalarSqrt ( muDoubleScalarAbs ( rtB . l1nevfnqpf ) ) ; rtDW . d1wjbe2mwx = 1 ; } else { rtB . pqjo5cmif3 = muDoubleScalarSqrt ( rtB . l1nevfnqpf ) ; } if ( ssIsModeUpdateTimeStep ( rtS ) ) { srUpdateBC ( rtDW . lkimmiwkfm ) ; } break ; } if ( rtP . spec_num == 1 ) { rtB . n4cgz4c1ig = rtB . escvsqytg5 ; } else { rtB . n4cgz4c1ig = rtB . pqjo5cmif3 ; } if ( ssIsModeUpdateTimeStep ( rtS ) ) { srUpdateBC ( rtDW . imhks3haia ) ; } } rtY . pt4snnlwkj = rtB . n4cgz4c1ig ; rtB . odqlvqmn2b = rtB . g4yktga2hl ; rtY . mnieqx4l3i = rtB . odqlvqmn2b ; rtY . hddohlna3z = rtU . czen2q1qls ; UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID3 ( int_T tid ) { rtB . fxvkky4cdu = rtP . Constant_Value_d4xw1fezi3 + rtP . Constant1_Value_frpjq2fffb ; if ( ssIsModeUpdateTimeStep ( rtS ) ) { srUpdateBC ( rtDW . imhks3haia ) ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { { real_T * * uBuffer = ( real_T * * ) & rtDW . gpxkxxnpkk . TUbufferPtrs [ 0 ] ; int_T numBuffers = 2 ; numBuffers = 3 ; real_T simTime = ssGetT ( rtS ) ; rtDW . amxtebsuok . Head = ( ( rtDW . amxtebsuok . Head < ( rtDW . amxtebsuok . CircularBufSize - 1 ) ) ? ( rtDW . amxtebsuok . Head + 1 ) : 0 ) ; if ( rtDW . amxtebsuok . Head == rtDW . amxtebsuok . Tail ) { if ( ! rt_TDelayUpdateTailOrGrowBuf ( & rtDW . amxtebsuok . CircularBufSize , & rtDW . amxtebsuok . Tail , & rtDW . amxtebsuok . Head , & rtDW . amxtebsuok . Last , simTime - rtP . fuelsystemtransportdelay_MaxDelay , uBuffer , ( boolean_T ) 0 , ( boolean_T ) 1 , & rtDW . amxtebsuok . MaxNewBufSize ) ) { ssSetErrorStatus ( rtS , "vtdelay memory allocation error" ) ; return ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "AbstractFuelControl_M1/Model 1/Cylinder and Exhaust/fuel system transport delay_TUbuffer0" , ( void * * ) ( & uBuffer [ 0 ] ) , numBuffers * rtDW . amxtebsuok . CircularBufSize * sizeof ( real_T ) , ( NULL ) , ( NULL ) ) ; } ( * uBuffer + rtDW . amxtebsuok . CircularBufSize ) [ rtDW . amxtebsuok . Head ] = simTime ; ( * uBuffer + 2 * rtDW . amxtebsuok . CircularBufSize ) [ rtDW . amxtebsuok . Head ] = rtX . ngshao3zxa ; ( * uBuffer ) [ rtDW . amxtebsuok . Head ] = rtB . nfrioqoa1z ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID3 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { XDot * _rtXdot ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> oxpohnjabn = rtB . kzu4511fzw ; _rtXdot -> dixd3f2rcr = 0.0 ; _rtXdot -> dixd3f2rcr += rtP . Throttledelay_A * rtX . dixd3f2rcr ; _rtXdot -> dixd3f2rcr += rtU . czen2q1qls ; _rtXdot -> ew102iggpt = rtB . keiyfhx4eg ; _rtXdot -> mnpnqi1mo5 = rtB . fthtwuev1r ; _rtXdot -> afa2wi01oy = rtB . eulxbwi45w ; { real_T instantDelay ; instantDelay = rtB . f5wvyzcfg5 ; if ( instantDelay > rtP . fuelsystemtransportdelay_MaxDelay ) { instantDelay = rtP . fuelsystemtransportdelay_MaxDelay ; } if ( instantDelay < 0.0 ) { _rtXdot -> ngshao3zxa = 0 ; } else { _rtXdot -> ngshao3zxa = 1.0 / instantDelay ; } } if ( rtDW . haix1u4b0d ) { ( ( XDot * ) ssGetdX ( rtS ) ) -> ed33yoocaq = 0.0 ; if ( rtDW . f2jjc1wq2q == 1 ) { _rtXdot -> ed33yoocaq = rtB . p2z1c52id3 ; } } else { ( ( XDot * ) ssGetdX ( rtS ) ) -> ed33yoocaq = 0.0 ; } } void MdlProjection ( void ) { } void MdlZeroCrossings ( void ) { ZCV * _rtZCSV ; _rtZCSV = ( ( ZCV * ) ssGetSolverZcSignalVector ( rtS ) ) ; _rtZCSV -> l5bd4ogmob = rtB . klp4ythknn - rtP . theta090_UpperSat ; _rtZCSV -> nyixy42sdh = rtB . klp4ythknn - rtP . theta090_LowerSat ; _rtZCSV -> fsqi2dsh3v = rtU . okzizglgcx - rtP . EngineSpeed9001100_UpperSat ; _rtZCSV -> exrdq4erzt = rtU . okzizglgcx - rtP . EngineSpeed9001100_LowerSat ; _rtZCSV -> jizglwcpdw = ssGetT ( rtS ) - rtP . fault_time ; if ( ( rtB . p0vdharg3x != rtB . p0vdharg3x ) || ( rtB . fskykcddjv < rtB . p0vdharg3x ) ) { if ( rtDW . jtmvk2k11t == 0 ) { _rtZCSV -> fxg0jjblig = rtB . fskykcddjv - rtB . fskykcddjv ; } else { _rtZCSV -> fxg0jjblig = rtB . fskykcddjv - rtB . p0vdharg3x ; } } else if ( rtDW . jtmvk2k11t == 0 ) { _rtZCSV -> fxg0jjblig = rtB . p0vdharg3x - rtB . fskykcddjv ; } else { _rtZCSV -> fxg0jjblig = rtB . p0vdharg3x - rtB . p0vdharg3x ; } _rtZCSV -> olhbe15f4n = rtB . kvvecvkv4w - rtP . Switch_Threshold_g5ldd2qgcy ; _rtZCSV -> frviirlf2h = rtB . mqlyzq05s5 ; _rtZCSV -> cv4m0d5kqn = ssGetT ( rtS ) - rtP . Pwon_Time ; _rtZCSV -> fycbfekjas = ssGetT ( rtS ) - rtP . measureTime ; if ( rtDW . haix1u4b0d ) { { ( ( ZCV * ) ssGetSolverZcSignalVector ( rtS ) ) -> gpmcbt2pph = 0.0 ; } if ( rtDW . f2jjc1wq2q == 1 ) { _rtZCSV -> gpmcbt2pph = ssGetT ( rtS ) - rtP . MeasureOn_Time ; } } else { { ( ( ZCV * ) ssGetSolverZcSignalVector ( rtS ) ) -> gpmcbt2pph = 0.0 ; } } } void MdlTerminate ( void ) { rt_TDelayFreeBuf ( rtDW . gpxkxxnpkk . TUbufferPtrs [ 0 ] ) ; } static void mr_AbstractFuelControl_M1_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_AbstractFuelControl_M1_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_AbstractFuelControl_M1_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_AbstractFuelControl_M1_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_AbstractFuelControl_M1_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_AbstractFuelControl_M1_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_AbstractFuelControl_M1_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_AbstractFuelControl_M1_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_AbstractFuelControl_M1_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_AbstractFuelControl_M1_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_AbstractFuelControl_M1_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_AbstractFuelControl_M1_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_AbstractFuelControl_M1_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_AbstractFuelControl_M1_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_AbstractFuelControl_M1_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_AbstractFuelControl_M1_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_AbstractFuelControl_M1_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "rtPrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 38 ] = { "rtDW.owav32xvsn" , "rtDW.a2qsprdgu1" , "rtDW.aiubtbumbt" , "rtDW.btjp423gxi" , "rtDW.lgypi2y43m" , "rtDW.lq35xsrymr" , "rtDW.j3e50spkrk" , "rtDW.fpmlnohs30" , "rtDW.lcyc3z0xe4" , "rtDW.oyzwbyjehp" , "rtDW.abqwkmfwm4" , "rtDW.kasy120l4j" , "rtDW.gh1igxnqfd" , "rtDW.enr4nh0hfz" , "rtDW.amxtebsuok" , "rtDW.gw2nevades" , "rtDW.beov4p1chl" , "rtDW.i1d01tl30y" , "rtDW.kmsrw41wv2" , "rtDW.ori3ob0wbj" , "rtDW.jtmvk2k11t" , "rtDW.g33icp3oa5" , "rtDW.lm0jugnir2" , "rtDW.dx43c5auhv" , "rtDW.e50m41o2zc" , "rtDW.ikdfizkwpn" , "rtDW.imhks3haia" , "rtDW.f2jjc1wq2q" , "rtDW.lkimmiwkfm" , "rtDW.d1wjbe2mwx" , "rtDW.bkxvh1udvf" , "rtDW.lxkp2jo22h" , "rtDW.ev00g24oaq" , "rtDW.nhy3an0buu" , "rtDW.meym2kkggb" , "rtDW.lqflcq5fag" , "rtDW.gqihgtfesf" , "rtDW.haix1u4b0d" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 38 , rtdwDataFieldNames ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . owav32xvsn ) , sizeof ( rtDW . owav32xvsn ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . a2qsprdgu1 ) , sizeof ( rtDW . a2qsprdgu1 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . aiubtbumbt ) , sizeof ( rtDW . aiubtbumbt ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . btjp423gxi ) , sizeof ( rtDW . btjp423gxi ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . lgypi2y43m ) , sizeof ( rtDW . lgypi2y43m ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . lq35xsrymr ) , sizeof ( rtDW . lq35xsrymr ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . j3e50spkrk ) , sizeof ( rtDW . j3e50spkrk ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . fpmlnohs30 ) , sizeof ( rtDW . fpmlnohs30 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . lcyc3z0xe4 ) , sizeof ( rtDW . lcyc3z0xe4 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . oyzwbyjehp ) , sizeof ( rtDW . oyzwbyjehp ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . abqwkmfwm4 ) , sizeof ( rtDW . abqwkmfwm4 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . kasy120l4j ) , sizeof ( rtDW . kasy120l4j ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . gh1igxnqfd ) , sizeof ( rtDW . gh1igxnqfd ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . enr4nh0hfz ) , sizeof ( rtDW . enr4nh0hfz ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . amxtebsuok ) , sizeof ( rtDW . amxtebsuok ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . gw2nevades ) , sizeof ( rtDW . gw2nevades ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . beov4p1chl ) , sizeof ( rtDW . beov4p1chl ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . i1d01tl30y ) , sizeof ( rtDW . i1d01tl30y ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( rtDW . kmsrw41wv2 ) , sizeof ( rtDW . kmsrw41wv2 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( rtDW . ori3ob0wbj ) , sizeof ( rtDW . ori3ob0wbj ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( rtDW . jtmvk2k11t ) , sizeof ( rtDW . jtmvk2k11t ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( rtDW . g33icp3oa5 ) , sizeof ( rtDW . g33icp3oa5 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( rtDW . lm0jugnir2 ) , sizeof ( rtDW . lm0jugnir2 ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( rtDW . dx43c5auhv ) , sizeof ( rtDW . dx43c5auhv ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( rtDW . e50m41o2zc ) , sizeof ( rtDW . e50m41o2zc ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( rtDW . ikdfizkwpn ) , sizeof ( rtDW . ikdfizkwpn ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( rtDW . imhks3haia ) , sizeof ( rtDW . imhks3haia ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( rtDW . f2jjc1wq2q ) , sizeof ( rtDW . f2jjc1wq2q ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( rtDW . lkimmiwkfm ) , sizeof ( rtDW . lkimmiwkfm ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( rtDW . d1wjbe2mwx ) , sizeof ( rtDW . d1wjbe2mwx ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 30 , ( const void * ) & ( rtDW . bkxvh1udvf ) , sizeof ( rtDW . bkxvh1udvf ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 31 , ( const void * ) & ( rtDW . lxkp2jo22h ) , sizeof ( rtDW . lxkp2jo22h ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 32 , ( const void * ) & ( rtDW . ev00g24oaq ) , sizeof ( rtDW . ev00g24oaq ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 33 , ( const void * ) & ( rtDW . nhy3an0buu ) , sizeof ( rtDW . nhy3an0buu ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 34 , ( const void * ) & ( rtDW . meym2kkggb ) , sizeof ( rtDW . meym2kkggb ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 35 , ( const void * ) & ( rtDW . lqflcq5fag ) , sizeof ( rtDW . lqflcq5fag ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 36 , ( const void * ) & ( rtDW . gqihgtfesf ) , sizeof ( rtDW . gqihgtfesf ) ) ; mr_AbstractFuelControl_M1_cacheDataAsMxArray ( rtdwData , 0 , 37 , ( const void * ) & ( rtDW . haix1u4b0d ) , sizeof ( rtDW . haix1u4b0d ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } mr_AbstractFuelControl_M1_cacheDataAsMxArray ( ssDW , 0 , 2 , ( const void * ) & ( rtPrevZCX ) , sizeof ( rtPrevZCX ) ) ; return ssDW ; } void mr_AbstractFuelControl_M1_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . owav32xvsn ) , rtdwData , 0 , 0 , sizeof ( rtDW . owav32xvsn ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . a2qsprdgu1 ) , rtdwData , 0 , 1 , sizeof ( rtDW . a2qsprdgu1 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . aiubtbumbt ) , rtdwData , 0 , 2 , sizeof ( rtDW . aiubtbumbt ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . btjp423gxi ) , rtdwData , 0 , 3 , sizeof ( rtDW . btjp423gxi ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lgypi2y43m ) , rtdwData , 0 , 4 , sizeof ( rtDW . lgypi2y43m ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lq35xsrymr ) , rtdwData , 0 , 5 , sizeof ( rtDW . lq35xsrymr ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . j3e50spkrk ) , rtdwData , 0 , 6 , sizeof ( rtDW . j3e50spkrk ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . fpmlnohs30 ) , rtdwData , 0 , 7 , sizeof ( rtDW . fpmlnohs30 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lcyc3z0xe4 ) , rtdwData , 0 , 8 , sizeof ( rtDW . lcyc3z0xe4 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . oyzwbyjehp ) , rtdwData , 0 , 9 , sizeof ( rtDW . oyzwbyjehp ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . abqwkmfwm4 ) , rtdwData , 0 , 10 , sizeof ( rtDW . abqwkmfwm4 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . kasy120l4j ) , rtdwData , 0 , 11 , sizeof ( rtDW . kasy120l4j ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . gh1igxnqfd ) , rtdwData , 0 , 12 , sizeof ( rtDW . gh1igxnqfd ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . enr4nh0hfz ) , rtdwData , 0 , 13 , sizeof ( rtDW . enr4nh0hfz ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . amxtebsuok ) , rtdwData , 0 , 14 , sizeof ( rtDW . amxtebsuok ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . gw2nevades ) , rtdwData , 0 , 15 , sizeof ( rtDW . gw2nevades ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . beov4p1chl ) , rtdwData , 0 , 16 , sizeof ( rtDW . beov4p1chl ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . i1d01tl30y ) , rtdwData , 0 , 17 , sizeof ( rtDW . i1d01tl30y ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . kmsrw41wv2 ) , rtdwData , 0 , 18 , sizeof ( rtDW . kmsrw41wv2 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . ori3ob0wbj ) , rtdwData , 0 , 19 , sizeof ( rtDW . ori3ob0wbj ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . jtmvk2k11t ) , rtdwData , 0 , 20 , sizeof ( rtDW . jtmvk2k11t ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . g33icp3oa5 ) , rtdwData , 0 , 21 , sizeof ( rtDW . g33icp3oa5 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lm0jugnir2 ) , rtdwData , 0 , 22 , sizeof ( rtDW . lm0jugnir2 ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . dx43c5auhv ) , rtdwData , 0 , 23 , sizeof ( rtDW . dx43c5auhv ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . e50m41o2zc ) , rtdwData , 0 , 24 , sizeof ( rtDW . e50m41o2zc ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . ikdfizkwpn ) , rtdwData , 0 , 25 , sizeof ( rtDW . ikdfizkwpn ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . imhks3haia ) , rtdwData , 0 , 26 , sizeof ( rtDW . imhks3haia ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . f2jjc1wq2q ) , rtdwData , 0 , 27 , sizeof ( rtDW . f2jjc1wq2q ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lkimmiwkfm ) , rtdwData , 0 , 28 , sizeof ( rtDW . lkimmiwkfm ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . d1wjbe2mwx ) , rtdwData , 0 , 29 , sizeof ( rtDW . d1wjbe2mwx ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . bkxvh1udvf ) , rtdwData , 0 , 30 , sizeof ( rtDW . bkxvh1udvf ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lxkp2jo22h ) , rtdwData , 0 , 31 , sizeof ( rtDW . lxkp2jo22h ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . ev00g24oaq ) , rtdwData , 0 , 32 , sizeof ( rtDW . ev00g24oaq ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . nhy3an0buu ) , rtdwData , 0 , 33 , sizeof ( rtDW . nhy3an0buu ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . meym2kkggb ) , rtdwData , 0 , 34 , sizeof ( rtDW . meym2kkggb ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . lqflcq5fag ) , rtdwData , 0 , 35 , sizeof ( rtDW . lqflcq5fag ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . gqihgtfesf ) , rtdwData , 0 , 36 , sizeof ( rtDW . gqihgtfesf ) ) ; mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtDW . haix1u4b0d ) , rtdwData , 0 , 37 , sizeof ( rtDW . haix1u4b0d ) ) ; } mr_AbstractFuelControl_M1_restoreDataFromMxArray ( ( void * ) & ( rtPrevZCX ) , ssDW , 0 , 2 , sizeof ( rtPrevZCX ) ) ; } mxArray * mr_AbstractFuelControl_M1_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 2 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 2 ] = { "Scope" , "Scope" , } ; static const char_T * blockPath [ 2 ] = { "AbstractFuelControl_M1/Monitor " , "AbstractFuelControl_M1/Model 1/Monitor" , } ; static const int reason [ 2 ] = { 0 , 0 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 2 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 7 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 3 ) ; ssSetNumU ( rtS , 2 ) ; ssSetDirectFeedThrough ( rtS , 1 ) ; ssSetNumSampleTimes ( rtS , 3 ) ; ssSetNumBlocks ( rtS , 193 ) ; ssSetNumBlockIO ( rtS , 77 ) ; ssSetNumBlockParams ( rtS , 186 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.0 ) ; ssSetSampleTime ( rtS , 2 , - 2.0 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 1.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 3328080310U ) ; ssSetChecksumVal ( rtS , 1 , 1960284117U ) ; ssSetChecksumVal ( rtS , 2 , 3069926035U ) ; ssSetChecksumVal ( rtS , 3 , 938795997U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; const int_T inportDataTypeIdx
[ ] = { 0 , 0 } ; const int_T inportDims [ ] = { 1 , 1 , 1 , 1 } ; const
int_T inportComplex [ ] = { 0 , 0 } ; const int_T inportInterpoFlag [ ] = { 1
, 1 } ; const int_T inportContinuous [ ] = { 1 , 1 } ; rt_modelMapInfoPtr = &
( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ;
executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_
. numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 2 ;
executionInfo -> gblObjects_ . numRootInportBlks = 2 ; executionInfo ->
gblObjects_ . inportDataTypeIdx = ( int_T * ) calloc ( 2 , sizeof ( int_T ) )
; memcpy ( executionInfo -> gblObjects_ . inportDataTypeIdx ,
inportDataTypeIdx , sizeof ( inportDataTypeIdx ) ) ; executionInfo ->
gblObjects_ . inportDims = ( int_T * ) calloc ( 2 * 2 , sizeof ( int_T ) ) ;
memcpy ( executionInfo -> gblObjects_ . inportDims , inportDims , sizeof ( inportDims ) ) ; executionInfo -> gblObjects_ . inportComplex = ( int_T * ) calloc ( 2 , sizeof ( int_T ) ) ; memcpy ( executionInfo -> gblObjects_ . inportComplex , inportComplex , sizeof ( inportComplex ) ) ; executionInfo -> gblObjects_ . inportInterpoFlag = ( int_T * ) calloc ( 2 , sizeof ( int_T ) ) ; memcpy ( executionInfo -> gblObjects_ . inportInterpoFlag , inportInterpoFlag , sizeof ( inportInterpoFlag ) ) ; executionInfo -> gblObjects_ . inportContinuous = ( int_T * ) calloc ( 2 , sizeof ( int_T ) ) ; memcpy ( executionInfo -> gblObjects_ . inportContinuous , inportContinuous , sizeof ( inportContinuous ) ) ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; { rtB . odqlvqmn2b = 0.0 ; rtB . j1xad1kw2y = 0.0 ; rtB . n4cgz4c1ig = 0.0 ; rtB . cfq25lfyyw = 0.0 ; rtB . l1nevfnqpf = 0.0 ; rtB . oyuelozcmi = 0.0 ; rtB . dizvn0c2kv = 0.0 ; rtB . p2z1c52id3 = 0.0 ; rtB . pqjo5cmif3 = 0.0 ; rtB . ljxgkjd15j = 0.0 ; rtB . escvsqytg5 = 0.0 ; rtB . no3zx0ezfz = 0.0 ; rtB . cqfpshtxvd = 0.0 ; rtB . pkw2gccdta = 0.0 ; rtB . klp4ythknn = 0.0 ; rtB . mgqkkfzlvr = 0.0 ; rtB . adzxmfdvct = 0.0 ; rtB . b0hwckgura = 0.0 ; rtB . kx21h31n2g = 0.0 ; rtB . lmmtdwu0wp = 0.0 ; rtB . e0hefnwpn5 = 0.0 ; rtB . jccvex1ixq = 0.0 ; rtB . fskykcddjv = 0.0 ; rtB . p0vdharg3x = 0.0 ; rtB . kvvecvkv4w = 0.0 ; rtB . d2xczoi00g = 0.0 ; rtB . mqlyzq05s5 = 0.0 ; rtB . edkdzixy33 = 0.0 ; rtB . jrd3m1e14e = 0.0 ; rtB . dv5kghuyay = 0.0 ; rtB . oftupsnnwq = 0.0 ; rtB . kdatkznqf3 = 0.0 ; rtB . kzu4511fzw = 0.0 ; rtB . bq2aoymfa2 = 0.0 ; rtB . b0d12gfpcn = 0.0 ; rtB . ggljthsrvd = 0.0 ; rtB . eklk3dmin0 = 0.0 ; rtB . oo3ejug25p = 0.0 ; rtB . a0lpbr03kt = 0.0 ; rtB . b3qds3z03d = 0.0 ; rtB . ojzkzpds5k = 0.0 ; rtB . fpznfvuttn = 0.0 ; rtB . iefpdh24wc = 0.0 ; rtB . hdznuhk51n = 0.0 ; rtB . h2gumn0zfz = 0.0 ; rtB . nfrioqoa1z = 0.0 ; rtB . gh4si2bfc3 = 0.0 ; rtB . nfkbndd5rw = 0.0 ; rtB . fthtwuev1r = 0.0 ; rtB . inb2szn322 = 0.0 ; rtB . f5wvyzcfg5 = 0.0 ; rtB . ok00lxzmk0 = 0.0 ; rtB . keiyfhx4eg = 0.0 ; rtB . gczfrkzoxa = 0.0 ; rtB . c3siktwmor = 0.0 ; rtB . aexnc2oizh = 0.0 ; rtB . eulxbwi45w = 0.0 ; rtB . g1ctig4m3i = 0.0 ; rtB . ak0qj52dtk = 0.0 ; rtB . mdypthjkfn = 0.0 ; rtB . dbtddmdnlk = 0.0F ; rtB . g1kfu2k5fh = 0.0F ; rtB . hto3u2ooh4 = 0.0F ; rtB . j0q4aipzzu = 0.0F ; rtB . ige0xs0xi4 = 0.0F ; rtB . iwmpiqqojt = 0.0F ; rtB . fxvkky4cdu = 0.0F ; rtB . g1sdxnua3f = 0.0F ; rtB . hpdu0hetw0 = 0.0F ; } } { ssSetU ( rtS , ( ( void * ) & rtU ) ) ; rtU . okzizglgcx = 0.0 ; rtU . czen2q1qls = 0.0 ; } { ssSetY ( rtS , & rtY ) ; rtY . pt4snnlwkj = 0.0 ; rtY . mnieqx4l3i = 0.0 ; rtY . hddohlna3z = 0.0 ; ssSetWorkSizeInBytes ( rtS , sizeof ( rtY ) , "YOut" ) ; } { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; rtDW . owav32xvsn = 0.0 ; rtDW . aiubtbumbt . modelTStart = 0.0 ; rtDW . btjp423gxi = 0.0F ; rtDW . lgypi2y43m = 0.0F ; rtDW . lq35xsrymr = 0.0F ; rtDW . j3e50spkrk = 0.0F ; rtDW . fpmlnohs30 = 0.0F ; rtDW . lcyc3z0xe4 = 0.0F ; rtDW . oyzwbyjehp = 0.0F ; rtDW . abqwkmfwm4 = 0.0F ; rtDW . kasy120l4j = 0.0F ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 23 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } AbstractFuelControl_M1_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "AbstractFuelControl_M1" ) ; ssSetPath ( rtS , "AbstractFuelControl_M1" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 50.0 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_SINGLE , SS_SINGLE , SS_SINGLE , SS_BOOLEAN , SS_BOOLEAN , SS_BOOLEAN } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "DSTATE" , "DSTATE" , "DSTATE" , "DSTATE" , "DSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "AbstractFuelControl_M1/V&V stub system/Calcuate Error/RMS error/Integrator" , "AbstractFuelControl_M1/Model 1/Cylinder and Exhaust/A//F_sensor/Filter/Integrator" , "AbstractFuelControl_M1/Model 1/Throttle delay" , "AbstractFuelControl_M1/Model 1/Intake Manifold/p0 = 0.543 (bar)" , "AbstractFuelControl_M1/Model 1/Cylinder and Exhaust/Filter/Integrator" , "AbstractFuelControl_M1/Model 1/Wall wetting/Integrator" , "AbstractFuelControl_M1/Model 1/Cylinder and Exhaust/fuel system transport delay" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_mode_10ms/normal_mode_detection/Unit Delay2" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_10ms/feedback_PI_controller/UnitDelay1" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_10ms/air_estimation/UnitDelay1" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_mode_10ms/sensor_failure_detection/Unit Delay" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_mode_10ms/power_mode_detection/Unit Delay1" , "AbstractFuelControl_M1/Model 1/AF_Controller/fuel_controller/fuel_controller_mode_10ms/normal_mode_detection/Unit Delay1" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_SINGLE , SS_SINGLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_SINGLE , SS_SINGLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_SINGLE , SS_SINGLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_BOOLEAN , SS_BOOLEAN , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_BOOLEAN , SS_BOOLEAN , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_BOOLEAN , SS_BOOLEAN , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 6 , 7 , 8 , 26 , 27 , 28 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 13 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 13 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . ed33yoocaq ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtX . oxpohnjabn ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtX . dixd3f2rcr ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtX . ew102iggpt ; rt_LoggedStateSignalPtrs [ 4 ] = ( void * ) & rtX . mnpnqi1mo5 ; rt_LoggedStateSignalPtrs [ 5 ] = ( void * ) & rtX . afa2wi01oy ; rt_LoggedStateSignalPtrs [ 6 ] = ( void * ) & rtX . ngshao3zxa ; rt_LoggedStateSignalPtrs [ 7 ] = ( void * ) & rtDW . btjp423gxi ; rt_LoggedStateSignalPtrs [ 8 ] = ( void * ) & rtDW . lgypi2y43m ; rt_LoggedStateSignalPtrs [ 9 ] = ( void * ) & rtDW . lq35xsrymr ; rt_LoggedStateSignalPtrs [ 10 ] = ( void * ) & rtDW . dx43c5auhv ; rt_LoggedStateSignalPtrs [ 11 ] = ( void * ) & rtDW . e50m41o2zc ; rt_LoggedStateSignalPtrs [ 12 ] = ( void * ) & rtDW . ikdfizkwpn ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "t" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "tmp_raccel_xout" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 2 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; { static void * rt_LoggedOutputSignalPtrs [ ] = { & rtY . pt4snnlwkj , & rtY . mnieqx4l3i , & rtY . hddohlna3z } ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( ( LogSignalPtrsType ) rt_LoggedOutputSignalPtrs ) ) ; } { static int_T rt_LoggedOutputWidths [ ] = { 1 , 1 , 1 } ; static int_T rt_LoggedOutputNumDimensions [ ] = { 1 , 1 , 1 } ; static int_T rt_LoggedOutputDimensions [ ] = { 1 , 1 , 1 } ; static boolean_T rt_LoggedOutputIsVarDims [ ] = { 0 , 0 , 0 } ; static void * rt_LoggedCurrentSignalDimensions [ ] = { ( NULL ) , ( NULL ) , ( NULL ) } ; static int_T rt_LoggedCurrentSignalDimensionsSize [ ] = { 4 , 4 , 4 } ; static BuiltInDTypeId rt_LoggedOutputDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedOutputComplexSignals [ ] = { 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingPreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedOutputLabels_0 [ ] = { "Verificaton Measurement" } ; static const char_T * rt_LoggedOutputBlockNames_0 [ ] = { "AbstractFuelControl_M1/verificaton measurement" } ; static const char_T * rt_LoggedOutputLabels_1 [ ] = { "Controller Mode" } ; static const char_T * rt_LoggedOutputBlockNames_1 [ ] = { "AbstractFuelControl_M1/mode" } ; static const char_T * rt_LoggedOutputLabels_2 [ ] = { "Pedal Angle" } ; static const char_T * rt_LoggedOutputBlockNames_2 [ ] = { "AbstractFuelControl_M1/pedal angle" } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static RTWLogSignalInfo rt_LoggedOutputSignalInfo [ ] = { { 1 , rt_LoggedOutputWidths , rt_LoggedOutputNumDimensions , rt_LoggedOutputDimensions , rt_LoggedOutputIsVarDims , rt_LoggedCurrentSignalDimensions , rt_LoggedCurrentSignalDimensionsSize , rt_LoggedOutputDataTypeIds , rt_LoggedOutputComplexSignals , ( NULL ) , rt_LoggingPreprocessingFcnPtrs , { rt_LoggedOutputLabels_0 } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedOutputBlockNames_0 } , { ( NULL ) } , ( NULL ) , rt_RTWLogDataTypeConvert , ( NULL ) } , { 1 , rt_LoggedOutputWidths + 1 , rt_LoggedOutputNumDimensions + 1 , rt_LoggedOutputDimensions + 1 , rt_LoggedOutputIsVarDims + 1 , rt_LoggedCurrentSignalDimensions + 1 , rt_LoggedCurrentSignalDimensionsSize + 1 , rt_LoggedOutputDataTypeIds + 1 , rt_LoggedOutputComplexSignals + 1 , ( NULL ) , rt_LoggingPreprocessingFcnPtrs + 1 , { rt_LoggedOutputLabels_1 } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedOutputBlockNames_1 } , { ( NULL ) } , ( NULL ) , rt_RTWLogDataTypeConvert + 1 , ( NULL ) } , { 1 , rt_LoggedOutputWidths + 2 , rt_LoggedOutputNumDimensions + 2 , rt_LoggedOutputDimensions + 2 , rt_LoggedOutputIsVarDims + 2 , rt_LoggedCurrentSignalDimensions + 2 , rt_LoggedCurrentSignalDimensionsSize + 2 , rt_LoggedOutputDataTypeIds + 2 , rt_LoggedOutputComplexSignals + 2 , ( NULL ) , rt_LoggingPreprocessingFcnPtrs + 2 , { rt_LoggedOutputLabels_2 } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedOutputBlockNames_2 } , { ( NULL ) } , ( NULL ) , rt_RTWLogDataTypeConvert + 2 , ( NULL ) } } ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , rt_LoggedOutputSignalInfo ) ; rt_LoggedCurrentSignalDimensions [ 0 ] = & rt_LoggedOutputWidths [ 0 ] ; rt_LoggedCurrentSignalDimensions [ 1 ] = & rt_LoggedOutputWidths [ 1 ] ; rt_LoggedCurrentSignalDimensions [ 2 ] = & rt_LoggedOutputWidths [ 2 ] ; } rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "tmp_raccel_yout1,tmp_raccel_yout2,tmp_raccel_yout3" ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static boolean_T contStatesDisabled [ 7 ] ; static real_T absTol [ 7 ] = { 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 } ; static uint8_T absTolControl [ 7 ] = { 2U , 2U , 2U , 2U , 2U , 2U , 2U } ; static real_T contStateJacPerturbBoundMinVec [ 7 ] ; static real_T contStateJacPerturbBoundMaxVec [ 7 ] ; static uint8_T zcAttributes [ 14 ] = { ( ZC_EVENT_ALL_UP ) , ( ZC_EVENT_ALL_UP ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL_UP ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL_UP ) , ( 0xc0 | ZC_EVENT_ALL_UP ) , ( 0xc0 | ZC_EVENT_ALL_UP ) , ( 0xc0 | ZC_EVENT_ALL_UP ) } ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 2 ] = { { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . dizvn0c2kv ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . edkdzixy33 ) , ( NULL ) } } ; { int i ; for ( i = 0 ; i < 7 ; ++ i ) { contStateJacPerturbBoundMinVec [ i ] = 0 ; contStateJacPerturbBoundMaxVec [ i ] = rtGetInf ( ) ; } } ssSetSolverRelTol ( rtS , 1.0E-6 ) ; ssSetStepSize ( rtS , 0.0 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 1.0 ) ; ssSetSolverMaxOrder ( rtS , 5 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , ( NULL ) ) ; ssSetNumOutputTimes ( rtS , 0 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 0 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 2 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "ode15s" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetAbsTolVector ( rtS , absTol ) ; ssSetAbsTolControlVector ( rtS , absTolControl ) ; ssSetSolverAbsTol_Obsolete ( rtS , absTol ) ; ssSetSolverAbsTolControl_Obsolete ( rtS , absTolControl ) ; ssSetJacobianPerturbationBoundsMinVec ( rtS , contStateJacPerturbBoundMinVec ) ; ssSetJacobianPerturbationBoundsMaxVec ( rtS , contStateJacPerturbBoundMaxVec ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetSolverZcSignalAttrib ( rtS , zcAttributes ) ; ssSetSolverNumZcSignals ( rtS , 14 ) ; ssSetModelZeroCrossings ( rtS , MdlZeroCrossings ) ; ssSetSolverConsecutiveZCsStepRelTol ( rtS , 2.8421709430404E-13 ) ; ssSetSolverMaxConsecutiveZCs ( rtS , 1000 ) ; ssSetSolverConsecutiveZCsError ( rtS , 2 ) ; ssSetSolverMaskedZcDiagnostic ( rtS , 1 ) ; ssSetSolverIgnoredZcDiagnostic ( rtS , 1 ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; ssSetSolverShapePreserveControl ( rtS , 2 ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 11 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; } { ZCSigState * zc = ( ZCSigState * ) & rtPrevZCX ; ssSetPrevZCSigState ( rtS , zc ) ; } { rtPrevZCX . k23vkqx30c = UNINITIALIZED_ZCSIG ; rtPrevZCX . behaxxarnb = UNINITIALIZED_ZCSIG ; rtPrevZCX . edwiftu20j = UNINITIALIZED_ZCSIG ; } ssSetChecksumVal ( rtS , 0 , 3328080310U ) ; ssSetChecksumVal ( rtS , 1 , 1960284117U ) ; ssSetChecksumVal ( rtS , 2 , 3069926035U ) ; ssSetChecksumVal ( rtS , 3 , 938795997U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 21 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = ( sysRanDType * ) & rtDW . nhy3an0buu ; systemRan [ 2 ] = ( sysRanDType * ) & rtDW . nhy3an0buu ; systemRan [ 3 ] = ( sysRanDType * ) & rtDW . meym2kkggb ; systemRan [ 4 ] = ( sysRanDType * ) & rtDW . nhy3an0buu ; systemRan [ 5 ] = ( sysRanDType * ) & rtDW . nhy3an0buu ; systemRan [ 6 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 7 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 8 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 9 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 10 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 11 ] = ( sysRanDType * ) & rtDW . ev00g24oaq ; systemRan [ 12 ] = ( sysRanDType * ) & rtDW . lxkp2jo22h ; systemRan [ 13 ] = & rtAlwaysEnabled ; systemRan [ 14 ] = & rtAlwaysEnabled ; systemRan [ 15 ] = & rtAlwaysEnabled ; systemRan [ 16 ] = & rtAlwaysEnabled ; systemRan [ 17 ] = ( sysRanDType * ) & rtDW . lkimmiwkfm ; systemRan [ 18 ] = ( sysRanDType * ) & rtDW . bkxvh1udvf ; systemRan [ 19 ] = ( sysRanDType * ) & rtDW . imhks3haia ; systemRan [ 20 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_AbstractFuelControl_M1_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_AbstractFuelControl_M1_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_AbstractFuelControl_M1_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID3 ( tid ) ; }
